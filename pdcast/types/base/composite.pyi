"""Mypy stubs for pdcast/types/base/composite.pyx"""
from typing import Any, Iterable, Iterator

import numpy as np

from pdcast.types import ScalarType, Type, VectorType
from pdcast.util.type_hints import type_specifier


rle_array = np.ndarray[
    Any, np.dtype[[("value", ScalarType), ("count", np.int64)]]  # type: ignore
]


class CompositeType(Type):
    types: set[VectorType]

    def __init__(
        self, types: Type | Iterable[Type] | None = ..., index: rle_array | None = ...
    ) -> None:
        ...

    ############################
    ####    CONSTRUCTORS    ####
    ############################

    @property
    def index(self) -> np.ndarray[ScalarType, np.dtype[object]]: ...
    def from_string(self, *args: str) -> CompositeType: ...

    ##########################
    ####    MEMBERSHIP    ####
    ##########################

    def contains(self, other: type_specifier) -> bool: ...

    ###########################
    ####    HIERARCHIES    ####
    ###########################

    def expand(self) -> CompositeType: ...
    def collapse(self) -> CompositeType: ...

    #############################
    ####    SET INTERFACE    ####
    #############################

    def add(self, other: type_specifier) -> None: ...
    def remove(self, other: type_specifier) -> None: ...
    def discard(self, other: type_specifier) -> None: ...
    def pop(self) -> VectorType: ...
    def clear(self) -> None: ...
    def copy(self) -> CompositeType: ...

    ##########################
    ####    OPERATIONS    ####
    ##########################

    def union(self, *others: type_specifier) -> CompositeType: ...
    def intersection(self, *others: type_specifier) -> CompositeType: ...
    def difference(self, *others: type_specifier) -> CompositeType: ...
    def symmetric_difference(self, other: type_specifier) -> CompositeType: ...
    def __or__(self, other: type_specifier) -> CompositeType: ...
    def __and__(self, other: type_specifier) -> CompositeType: ...
    def __sub__(self, other: type_specifier) -> CompositeType: ...
    def __xor__(self, other: type_specifier) -> CompositeType: ...

    ###################################
    ####    IN-PLACE OPERATIONS    ####
    ###################################

    def update(self, *others: type_specifier) -> None: ...
    def intersection_update(self, *others: type_specifier) -> None: ...
    def difference_update(self, *others: type_specifier) -> None: ...
    def symmetric_difference_update(self, other: type_specifier) -> None: ...
    def __ior__(self, other: type_specifier) -> CompositeType: ...
    def __iand__(self, other: type_specifier) -> CompositeType: ...
    def __isub__(self, other: type_specifier) -> CompositeType: ...
    def __ixor__(self, other: type_specifier) -> CompositeType: ...

    ###########################
    ####    COMPARISONS    ####
    ###########################

    def issubset(self, other: type_specifier) -> bool: ...
    def issuperset(self, other: type_specifier) -> bool: ...
    def isdisjoint(self, other: type_specifier) -> bool: ...
    def __gt__(self, other: type_specifier) -> bool: ...
    def __ge__(self, other: type_specifier) -> bool: ...
    def __eq__(self, other: type_specifier) -> bool: ...
    def __lt__(self, other: type_specifier) -> bool: ...
    def __le__(self, other: type_specifier) -> bool: ...

    ###############################
    ####    SPECIAL METHODS    ####
    ###############################

    def __bool__(self) -> bool: ...
    def __contains__(self, other: type_specifier) -> bool: ...
    def __iter__(self) -> Iterator[VectorType]: ...
    def __len__(self) -> int: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
