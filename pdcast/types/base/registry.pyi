"""Mypy stubs for pdcast/types/base/registry.pyx"""
import regex as re  # type: ignore
from typing import Any, Callable, Iterable, Iterator, Mapping

from pdcast.types import AbstractType, CompositeType, ScalarType, VectorType
from pdcast.util.type_hints import array_like, dtype_like, type_specifier


edge = tuple[Any, Any]


def register(
    class_: type = ..., *, cond: bool = ...
) -> Callable[[type], VectorType | type]:
    ...


class TypeRegistry:
    def __init__(self) -> None: ...

    ############################
    ####    REGISTRATION    ####
    ############################

    def add(self, typ: VectorType | type) -> None: ...
    def remove(self, typ: type_specifier) -> None: ...

    #####################
    ####    STATE    ####
    #####################

    @property
    def hash(self) -> int: ...
    def flush(self) -> None: ...

    #########################
    ####    ACCESSORS    ####
    #########################

    @property
    def roots(self) -> CompositeType: ...
    @property
    def leaves(self) -> CompositeType: ...
    @property
    def families(self) -> Mapping[str, CompositeType]: ...
    @property
    def decoraotors(self) -> CompositeType: ...
    @property
    def abstract(self) -> CompositeType: ...

    #####################
    ####    REGEX    ####
    #####################

    @property
    def aliases(self) -> Mapping[str, type_specifier]: ...
    @property
    def regex(self) -> re.Pattern: ...
    @property
    def resolvable(self) -> re.Pattern: ...

    #############################
    ####    RELATIONSHIPS    ####
    #############################

    def get_default(self, typ: AbstractType) -> ScalarType: ...
    def get_supertype(self, typ: ScalarType) -> AbstractType: ...
    def get_subtypes(self, typ: AbstractType) -> CompositeType: ...
    def get_generic(self, typ: ScalarType) -> ScalarType: ...
    def get_implementations(self, typ: AbstractType) -> Mapping[str, ScalarType]: ...

    #############################
    ####    CONFIGURATION    ####
    #############################

    @property
    def priority(self) -> PrioritySet: ...

    ###############################
    ####    SPECIAL METHODS    ####
    ###############################

    def __iter__(self) -> Iterator[VectorType]: ...
    def __len__(self) -> int: ...
    def __contains__(self, typ: VectorType | type) -> bool: ...
    def __getitem__(self, typ: VectorType | type) -> bool: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class Type:
    registry: TypeRegistry

    #######################
    ####    ALIASES    ####
    #######################

    @property
    def aliases(self) -> AliasManager: ...

    ############################
    ####    CONSTRUCTORS    ####
    ############################

    def from_string(self, *args: str) -> Type: ...
    def from_dtype(
        self, dtype: dtype_like, array_like: array_like | None = ...
    ) -> Type:
        ...
    def from_scalar(self, example: Any) -> Type: ...

    ##########################
    ####    MEMBERSHIP    ####
    ##########################

    def contains(self, other: type_specifier) -> bool: ...
    def __contains__(self, other: type_specifier) -> bool: ...


class CacheValue:
    hash: int
    value: Any

    def __init__(self, value: Any) -> None: ...
    def __bool__(self) -> bool: ...


class AliasManager:
    instance: Type

    def __init__(self, instance: Type) -> None: ...

    #############################
    ####    SET INTERFACE    ####
    #############################

    def add(
        self, alias: type_specifier, overwrite: bool = ..., pin: bool = ...
    ) -> None:
        ...
    def remove(self, alias: type_specifier, pin: bool = ...) -> None: ...
    def discard(self, alias: type_specifier) -> None: ...
    def pop(self) -> type_specifier: ...
    def clear(self) -> None: ...

    ##############################
    ####    SET OPERATIONS    ####
    ##############################

    def __or__(self, other: set[Any]) -> set[Any]: ...
    def __and__(self, other: set[Any]) -> set[Any]: ...
    def __sub__(self, other: set[Any]) -> set[Any]: ...
    def __xor__(self, other: set[Any]) -> set[Any]: ...

    ###############################
    ####    SPECIAL METHODS    ####
    ###############################

    def __bool__(self) -> bool: ...
    def __len__(self) -> int: ...
    def __contains__(self, alias: type_specifier) -> bool: ...
    def __iter__(self) -> Iterator[type_specifier]: ...
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...


class PrioritySet(set[tuple[type, type]]):
    def add(self, item: edge) -> None: ...
    def remove(self, item: edge) -> None: ...
    def discard(self, item: edge) -> None: ...
    def update(self, *others: Iterable[edge]) -> None: ...
    def intersection_update(self, *others: Iterable[edge]) -> None: ...
    def difference_update(self, *others: Iterable[edge]) -> None: ...
    def symmetric_difference_update(self, other: Iterable[edge]) -> None: ...
    def __ior__(self, other: Iterable[edge]) -> PrioritySet: ...  # type: ignore
    def __iand__(self, other: Iterable[edge]) -> PrioritySet: ...  # type: ignore
    def __isub__(self, other: Iterable[edge]) -> PrioritySet: ...  # type: ignore
    def __ixor__(self, other: Iterable[edge]) -> PrioritySet: ...  # type: ignore
    def __contains__(self, item: edge) -> bool: ...  # type: ignore
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...
