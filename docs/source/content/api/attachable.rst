.. currentmodule:: pdcast

.. testsetup::

    import numpy as np
    import pandas as pd
    from pdcast import *

pdcast.attachable
=================

.. autodecorator:: attachable

.. _attachable.decorated:

Attachable functions
--------------------
:func:`@attachable <attachable>` transforms the decorated callable into an
:class:`Attachable` object, which can be easily `bound
<https://realpython.com/python-descriptors/#python-descriptors-in-methods-and-functions>`_
to external classes.  This adds the following attributes to its interface, in
addition to any that are present on the callable itself (see
:ref:`nested decorators <attachable.nested>`).

.. autosummary::
    :toctree: ../../generated

    Attachable
    Attachable.attached
    Attachable.attach_to

The behavior of the original function is otherwise unchanged.

.. doctest::

    >>> @attachable
    ... def foo(data):
    ...     print("Hello, World!")
    ...     return data

    >>> foo(1)
    Hello, World!
    1

.. _attachable.attributes:

Virtual Attributes
------------------
Virtual attributes are generated by :meth:`Attachable.attach_to` according to
the ``pattern`` argument.  They come in a variety of formats.

.. autosummary::
    :toctree: ../../generated

    VirtualAttribute
    InstanceMethod
    ClassMethod
    StaticMethod
    Property

Each inherits the following attributes in addition to those of the decorated
function (see :ref:`nested decorators <attachable.nested>`):

.. autosummary::
    :toctree: ../../generated

    VirtualAttribute.original
    VirtualAttribute.detach
    VirtualAttribute.__get__

By default, :meth:`Attachable.attach_to` adds the decorated function as an
instance method of the given class.

.. doctest::

    >>> class MyClass:
    ...     def __repr__(self):
    ...         return "MyClass()"

    >>> foo.attach_to(MyClass)

This creates a new attribute ``MyClass.foo``, which is a self-binding wrapper
for the decorated function.  It behaves exactly like a normal instance method
of ``MyClass``.  For example:

.. doctest::

    >>> MyClass.foo   # doctest: +SKIP
    <function foo at 0x7fb5d383c4c0>
    >>> MyClass().foo()
    Hello, World!
    MyClass()

If we invoke ``MyClass.foo`` as a class method (i.e. without instantiating
``MyClass`` first), then we get the same behavior as the naked ``foo``
function.

.. doctest::

    >>> MyClass.foo()
    Traceback (most recent call last):
        ...
    TypeError: foo() missing 1 required positional argument: 'data'
    >>> MyClass.foo(MyClass())
    Hello, World!
    MyClass()

We can change this by specifying a different value for the ``pattern``
argument.

.. testsetup::

    MyClass.foo.detach()

.. doctest::

    >>> foo.attach_to(MyClass, pattern="classmethod")
    >>> MyClass.foo()
    Hello, World!
    <class '__main__.MyClass'>

This behaves as if our ``foo`` attribute were decorated with
:func:`@classmethod <python:classmethod>`.  We can do the same for
:func:`@staticmethod <python:staticmethod>`:

.. testsetup::

    MyClass.foo.detach()

.. doctest::

    >>> foo.attach_to(MyClass, pattern="staticmethod")
    >>> MyClass.foo()
    Traceback (most recent call last):
        ...
    TypeError: foo() missing 1 required positional argument: 'data'
    >>> MyClass().foo()
    Traceback (most recent call last):
        ...
    TypeError: foo() missing 1 required positional argument: 'data'

And :class:`@property <python:property>`, using the decorated function as the
getter.

.. testsetup::

    MyClass.foo.detach()

.. doctest::

    >>> foo.attach_to(MyClass, pattern="property")
    >>> MyClass().foo
    Hello, World!
    MyClass()

.. note::

    We can add a setter/deleter for our property using the normal
    :class:`@property <property>` interface.

    .. doctest::

        >>> @MyClass.foo.setter
        ... def foo_setter(data, value):
        ...     print(f"setting MyClass.foo to {value}")

        >>> @MyClass.foo.deleter
        ... def foo_deleter(data):
        ...     print("deleting MyClass.foo")

        >>> MyClass().foo = 2
        setting MyClass.foo to 2
        >>> del MyClass().foo
        deleting MyClass.foo

.. warning::

    For ``pattern="property"`` attributes, the :attr:`VirtualAttribute.original`
    interface will be inaccessible from any instance.

    .. doctest::

        >>> MyClass().foo.original
        Hello, World!
        Traceback (most recent call last):
            ...
        AttributeError: 'MyClass' object has no attribute 'original'

Finally, we can detach our virtual attribute using
:meth:`VirtualAttribute.detach`.

.. doctest::

    >>> MyClass.foo.detach()
    >>> MyClass().foo
    Traceback (most recent call last):
        ...
    AttributeError: 'MyClass' object has no attribute 'foo'

.. _attachable.namespace:

Namespaces
----------
:class:`Namespaces <Namespace>` are created via the ``namespace`` argument of
:meth:`Attachable.attach_to`.  They inherit the following interface:

.. autosummary::
    :toctree: ../../generated

    Namespace
    Namespace.original
    Namespace.attached
    Namespace.detach
    Namespace.__get__

Occasionally, namespace conflicts might emerge when attaching attributes to
existing classes.  For instance, if ``MyClass`` defines its own ``MyClass.foo``
method, then our attached ``foo`` function will mask the original.

.. doctest::

    >>> class MyClass:
    ...     def foo(self):
    ...         print("Goodbye, World!")
    ...         return self
    ... 
    ...     def __repr__(self):
    ...         return "MyClass()"

    >>> foo.attach_to(MyClass)
    >>> MyClass().foo()
    Hello, World!
    MyClass()

We can recover the masked method by calling the attribute's
:attr:`.original <VirtualAttribute.original>` accessor.

.. doctest::

    >>> MyClass().foo.original()
    Goodbye, World!
    MyClass()

But this is not done by default.  This means that any naive reference to
``MyClass.foo`` will automatically use our overloaded implementation, even if
that reference is internal to ``MyClass``.  This could lead to unexpected
behavior if our overloaded implementation returns a different result than the
method it masks.

In order to avoid this, we can either rename our overloaded method:

.. testsetup::

    MyClass.foo.detach()

.. doctest::

    >>> foo.attach_to(MyClass, name="bar")
    >>> MyClass.bar   # doctest: +SKIP
    <function foo at 0x7f50672f04c0>
    >>> MyClass().bar()
    Hello, World!
    MyClass()

Or hide it behind a virtual :class:`Namespace`, which separates it from the
existing attributes of ``MyClass``.

.. testsetup::

    MyClass.bar.detach()

.. doctest::

    >>> foo.attach_to(MyClass, namespace="baz")
    >>> MyClass.baz   # doctest: +SKIP
    <pdcast.decorators.attachable.Namespace object at 0x7fe73dd10af0>
    >>> MyClass.baz.foo   # doctest: +SKIP
    <function foo at 0x7fe73dd1c4c0>
    >>> MyClass().baz.foo()
    Hello, World!
    MyClass()

Both of these approaches leave the original ``foo`` method untouched.

.. doctest::

    >>> MyClass().foo()
    Goodbye, World!
    MyClass()

When we :meth:`detach() <VirtualAttribute.detach>` an attribute that is hidden
behind a namespace, that namespace will be automatically removed if it is not
managing any additional attributes.

.. doctest::

    >>> MyClass.baz.foo.detach()
    >>> MyClass().baz.foo()
    Traceback (most recent call last):
        ...
    AttributeError: 'MyClass' object has no attribute 'baz'

.. _attachable.nested:

Cooperative decorators
----------------------
.. TODO: confirm these

:func:`@attachable <attachable>` can be nested cooperatively with other
function decorators.  For example:

.. doctest::

    >>> @attachable
    ... @extension_func
    ... @dispatch
    ... def foo(bar, baz=2, **kwargs):
    ...     raise NotImplementedError(
    ...         f"foo() has no implementation for type: {bar.element_type}"
    ...     )

    >>> @foo.register_arg
    ... def baz(val, defaults):
    ...     return int(val)

    >>> @foo.overload("int")
    ... def integer_foo(bar, baz, **kwargs):
    ...     print("Hello, World!")
    ...     return bar + baz

    >>> foo.attach_to(pd.Series)

This gives the following order of operations:

    #.  If ``foo()`` is invoked from a :class:`pandas.Series` instance, insert
        it as the ``bar`` argument.
    #.  Validate the registered arguments (``baz``) and apply default values.
    #.  Dispatch to ``integer_foo()`` if ``bar`` contains integers, otherwise
        raise a :class:`NotImplementedError <python:NotImplementedError>`.

.. doctest::

    >>> pd.Series([1, 2, 3]).foo()
    Hello, World!
    0    3
    1    4
    2    5
    dtype: int64
    >>> pd.Series.foo.baz = "12"
    >>> pd.Series([1, 2, 3]).foo()
    Hello, World!
    0    13
    1    14
    2    15
    dtype: int64
    >>> pd.Series([1., 2., 3.]).foo()
    Traceback (most recent call last):
        ...
    NotImplementedError: foo() has no implementation for type: float64[numpy]

.. note::

    This is how :func:`cast` is implemented under the hood.

All attribute accesses will be passed down the decorator stack, combining the
interfaces of each decorator.

.. doctest::

    >>> foo.attached
    >>> foo.default_values
    >>> foo.dispatched

.. warning::

    Any :class:`ExtensionFunc` arguments (as well as their default values) will
    be shared between the :class:`Attachable` and its
    :ref:`bound attributes <attachable.attributes>`.

    .. doctest::

        >>> foo.baz
        12

    This might lead to unexpected changes in behavior if not properly accounted
    for.

Source
------
:func:`@attachable <attachable>` is implemented in pure Python and does not
require any ``pdcast``-specific functionality to work.  It is available as a
generic :doc:`recipe <source/attachable>`.

.. toctree::
    :hidden:

    source <source/attachable>
