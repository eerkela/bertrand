.. currentmodule:: pdcast

.. testsetup::

    import numpy as np
    import pandas as pd
    from pdcast import *

pdcast.attachable
=================

.. autodecorator:: attachable

.. _attachable.decorated:

Attachable functions
--------------------
:func:`@attachable <attachable>` transforms the decorated callable into an
:class:`Attachable` object, which can be easily bound to external classes.
This adds the following attributes to its interface, in addition to any that
are present on the callable itself (see
:ref:`nested decorators <attachable.nested>`).

.. autosummary::
    :toctree: ../../generated

    Attachable
    Attachable.attached
    Attachable.attach_to

The behavior of the original function is otherwise unchanged.

.. _attachable.attributes:

Bound Attributes
----------------
Bound attributes are generated by :meth:`Attachable.attach_to` according to its
``pattern`` argument.  They come in a variety of formats.

.. autosummary::
    :toctree: ../../generated

    BoundAttribute
    InstanceMethod
    ClassMethod
    StaticMethod

Each inherits the following attributes in addition to those of decorated
function (see :ref:`nested decorators <attachable.nested>`):

.. autosummary::
    :toctree: ../../generated

    BoundAttribute.original
    BoundAttribute.detach
    BoundAttribute.__get__

.. _attachable.namespace:

Namespaces
----------
:class:`Namespaces <Namespace>` are created via the ``namespace`` argument of
:meth:`Attachable.attach_to`.

.. autosummary::
    :toctree: ../../generated

    Namespace
    Namespace.original
    Namespace.attached
    Namespace.detach
    Namespace.__get__

.. _attachable.example:

Examples
--------
This decorator allows users to :meth:`attach <Attachable.attach_to>` any Python 
function as a `bound <https://realpython.com/python-descriptors/#python-descriptors-in-methods-and-functions>`_
attribute of an external class.  Here's an example:

.. doctest::

    >>> class MyClass:
    ...     def __init__(self, x):
    ...         self.x = x
    ... 
    ...     def __repr__(self):
    ...         return f"MyClass({self.x})"

    >>> @attachable
    ... def foo(data):
    ...     print("Hello, World!")
    ...     return data

    >>> foo.attach_to(MyClass)

This creates a new attribute ``MyClass.foo``, which is a self-binding wrapper
for the decorated function.  It behaves exactly like a normal instance method
of ``MyClass``.  For example:

.. doctest::

    >>> MyClass.foo   # doctest: +SKIP
    <function foo at 0x7fb5d383c4c0>
    >>> MyClass(1).foo()
    Hello, World!
    MyClass(1)

If we invoke ``MyClass.foo`` as a class method (i.e. without instantiating
``MyClass`` first), then we get the same behavior as the naked ``foo``
function.

.. doctest::

    >>> MyClass.foo()
    Traceback (most recent call last):
        ...
    TypeError: foo() missing 1 required positional argument: 'data'
    >>> MyClass.foo(MyClass(1))
    Hello, World!
    MyClass(1)

If ``MyClass`` defines its own ``foo`` method, then our attached method will
mask the original.

.. doctest::

    >>> class MyClass:
    ...     def __init__(self, x):
    ...         self.x = x
    ... 
    ...     def __repr__(self):
    ...         return f"MyClass({self.x})"
    ... 
    ...     def foo(self):
    ...         print("Goodbye, World!")
    ...         return self

    >>> foo.attach_to(MyClass)
    >>> MyClass(1).foo()
    Hello, World!
    MyClass(1)

We can recover the masked implementation by accessing the method's
:attr:`original <BoundAttribute.original>` attribute.

.. doctest::

    >>> MyClass(1).foo.original()
    Goodbye, World!
    MyClass(1)

Note that this is not done by default, so any naive reference to
``MyClass.foo`` will automatically use our overloaded implementation, even if
that reference is internal to ``MyClass``.  This could lead to unexpected
behavior if our overloaded implementation returns a different result than the
method it masks.  In order to avoid this, we can either rename our overloaded
method:

.. testsetup::

    MyClass.foo.detach()

.. doctest::

    >>> foo.attach_to(MyClass, name="bar")
    >>> MyClass.bar   # doctest: +SKIP
    <function foo at 0x7f50672f04c0>
    >>> MyClass(1).bar()
    Hello, World!
    MyClass(1)

Or hide it behind a virtual :class:`Namespace`, which separates it from the
existing attributes of ``MyClass``.

.. testsetup::

    MyClass.bar.detach()

.. doctest::

    >>> foo.attach_to(MyClass, namespace="baz")
    >>> MyClass.baz   # doctest: +SKIP
    <pdcast.func.virtual.Namespace object at 0x7fe73dd10af0>
    >>> MyClass.baz.foo   # doctest: +SKIP
    <function foo at 0x7fe73dd1c4c0>
    >>> MyClass(1).baz.foo()
    Hello, World!
    MyClass(1)

Both of these approaches leave the original ``foo`` method untouched.

.. doctest::

    >>> MyClass(1).foo()
    Goodbye, World!
    MyClass(1)

In addition, we can


We can remove our attached attribute by calling its
:meth:`detach() <BoundAttribute.detach>` method, which replaces the original
implementation if one exists.

.. doctest::

    >>> MyClass.baz.foo.detach()
    >>> MyClass.baz.foo
    Traceback (most recent call last):
        ...
    AttributeError: type object 'MyClass' has no attribute 'baz'

This automatically removes the namespace if it is not managing any
additional attributes.

.. _attachable.nested:

Nested decorators
-----------------
:func:`@attachable <attachable>` can be nested cooperatively with other
``pdcast`` function decorators.  For example:

.. doctest::

    >>> @attachable
    ... @extension_func
    ... @dispatch
    ... def foo(bar, baz=2, **kwargs):
    ...     raise NotImplementedError(
    ...         f"foo() has no implementation for type: {bar.element_type}"
    ...     )

    >>> @foo.register_arg
    ... def baz(val, defaults):
    ...     return int(val)

    >>> @foo.register_type(types="int")
    ... def integer_foo(bar, baz=2, **kwargs):
    ...     print("Hello, World!")
    ...     return bar + baz

    >>> foo.attach_to(pd.Series)
    >>> pd.Series([1, 2, 3]).foo()
    Hello, World!
    0    3
    1    4
    2    5
    dtype: int64
    >>> pd.Series.foo.baz = "12"
    >>> pd.Series([1, 2, 3]).foo()
    Hello, World!
    0    13
    1    14
    2    15
    dtype: int64
    >>> pd.Series([1., 2., 3.]).foo()
    Traceback (most recent call last):
        ...
    NotImplementedError: foo() has no implementation for type: float64[numpy]

This is exactly how the :func:`cast` function is implemented under the hood.

.. note::

    The arrangement of the above decorators is significant.  As shown, the
    order of operations is as follows:

        #.  If invoking from a :class:`pandas.Series` instance, insert it as
            the ``bar`` argument of ``foo()``.
        #.  Validate the registered arguments (``baz``) and apply default
            values.
        #.  Dispatch to ``integer_foo()`` if ``bar`` contains integers,
            otherwise raise a
            :class:`NotImplementedError <python:NotImplementedError>`.

.. warning::

    Any arguments (as well as their default values) will be shared between the
    :class:`InstanceMethod` and its decorated :class:`ExtensionFunc`.

    .. doctest::

        >>> foo.baz
        12

    This might lead to unexpected changes in behavior if not properly accounted
    for.
