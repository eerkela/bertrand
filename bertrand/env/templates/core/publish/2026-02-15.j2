{% raw %}
name: publish

on:
  push:
    tags:
      - "v*"
  workflow_dispatch:

permissions:
  contents: read
  packages: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  discover:
    name: Discover publish tags
    runs-on: ubuntu-24.04
    outputs:
      should_publish: ${{ steps.discover.outputs.should_publish }}
      tags_json: ${{ steps.discover.outputs.tags_json }}
    steps:
      - uses: actions/checkout@v4

      - id: discover
        name: Compute publish metadata
        shell: bash
        run: |
          python - <<'PY'
          import json
          import os
          import re
          from pathlib import Path


          def fail(message: str) -> None:
              raise SystemExit(message)


          event_name = os.getenv("GITHUB_EVENT_NAME", "")
          ref_type = os.getenv("GITHUB_REF_TYPE", "")
          ref_name = os.getenv("GITHUB_REF_NAME", "")
          short_sha = os.getenv("GITHUB_SHA", "")[:12]
          release_event = event_name in {"push", "workflow_dispatch"}

          tags: list[str] = []
          if release_event and ref_type == "branch" and ref_name == "main":
              tags = ["main"]
              if short_sha:
                  tags.append(f"sha-{short_sha}")
          elif release_event and ref_type == "tag":
              semver = re.fullmatch(r"v(\d+)\.(\d+)\.(\d+)", ref_name)
              if semver:
                  major, minor, patch = semver.groups()
                  tags = [
                      f"v{major}.{minor}.{patch}",
                      f"v{major}.{minor}",
                      f"v{major}",
                  ]

          should_publish = bool(tags)

          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              fail("missing GITHUB_OUTPUT")

          with Path(output_path).open("a", encoding="utf-8") as fh:
              fh.write(f"should_publish={'true' if should_publish else 'false'}\n")
              fh.write(
                  "tags_json="
                  f"{json.dumps(tags, separators=(',', ':'))}\n"
              )
          PY

  build_amd64:
    name: Build amd64 images
    needs: discover
    runs-on: ubuntu-24.04
    outputs:
      image_tags_json: ${{ steps.collect.outputs.image_tags_json }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Bertrand CLI
        shell: bash
        run: |
          python -m venv .venv
          . .venv/bin/activate
          python -m pip install --upgrade pip
          python -m pip install "bertrand=={% endraw %}{{ bertrand_version }}{% raw %}"
          echo "${PWD}/.venv/bin" >> "$GITHUB_PATH"

      - name: Bootstrap toolchain and build images
        shell: bash
        run: |
          bertrand init --yes
          bertrand build .

      - id: collect
        name: Collect amd64 image tags and publish refs
        shell: bash
        env:
          ARCH: amd64
          BASE_TAGS_JSON: ${{ needs.discover.outputs.tags_json }}
          SHOULD_PUBLISH: ${{ needs.discover.outputs.should_publish }}
        run: |
          python - <<'PY'
          import json
          import os
          import subprocess
          from pathlib import Path


          def fail(message: str) -> None:
              raise SystemExit(message)


          def run_capture(cmd: list[str]) -> str:
              cp = subprocess.run(cmd, check=True, capture_output=True, text=True)
              return cp.stdout


          def normalize_list(payload: object, where: str) -> list[object]:
              if isinstance(payload, list):
                  return payload
              fail(f"expected list at {where}")


          ls_raw = run_capture(["bertrand", "ls", ".", "--images", "--json"])
          ls_payload = json.loads(ls_raw)
          ls_rows = normalize_list(ls_payload, "bertrand ls output")

          image_ids: list[str] = []
          seen_ids: set[str] = set()
          for row in ls_rows:
              if not isinstance(row, dict):
                  continue
              image_id = None
              for key in ("Id", "ID", "ImageID", "ImageId"):
                  value = row.get(key)
                  if isinstance(value, str) and value.strip():
                      image_id = value.strip()
                      break
              if image_id is None or image_id in seen_ids:
                  continue
              seen_ids.add(image_id)
              image_ids.append(image_id)

          if not image_ids:
              fail("no Bertrand images were found after build")

          tag_to_id: dict[str, str] = {}
          for image_id in image_ids:
              inspect_raw = run_capture(["podman", "image", "inspect", image_id])
              inspect_payload = json.loads(inspect_raw)
              if isinstance(inspect_payload, list):
                  if not inspect_payload:
                      continue
                  inspect_obj = inspect_payload[0]
              else:
                  inspect_obj = inspect_payload

              if not isinstance(inspect_obj, dict):
                  fail(f"invalid inspect payload for image id: {image_id}")

              labels = inspect_obj.get("Labels")
              if labels is None:
                  labels = {}
              if not isinstance(labels, dict):
                  fail(f"invalid image labels for image id: {image_id}")

              image_tag = labels.get("BERTRAND_IMAGE")
              if not isinstance(image_tag, str):
                  fail(
                      "missing BERTRAND_IMAGE label in inspect data for image id: "
                      f"{image_id}"
                  )

              existing_id = tag_to_id.get(image_tag)
              if existing_id is not None and existing_id != image_id:
                  fail(f"duplicate built image tag detected: '{image_tag}'")
              tag_to_id[image_tag] = image_id

          if not tag_to_id:
              fail("no Bertrand image tags discovered from inspect labels")

          ordered_tags: list[str] = []
          if "" in tag_to_id:
              ordered_tags.append("")
          ordered_tags.extend(sorted(tag for tag in tag_to_id if tag))

          should_publish = os.environ.get("SHOULD_PUBLISH", "false").lower() == "true"
          base_tags = json.loads(os.environ.get("BASE_TAGS_JSON", "[]"))
          if not isinstance(base_tags, list) or not all(isinstance(x, str) for x in base_tags):
              fail("BASE_TAGS_JSON must decode to list[str]")

          repo = f"ghcr.io/{os.environ['GITHUB_REPOSITORY'].lower()}"
          arch = os.environ["ARCH"]

          publish_refs: list[dict[str, str]] = []
          if should_publish:
              for image_tag in ordered_tags:
                  suffix = f"-{image_tag}" if image_tag else ""
                  source_id = tag_to_id[image_tag]
                  for base in base_tags:
                      publish_refs.append({
                          "source_id": source_id,
                          "target_ref": f"{repo}:{base}{suffix}-{arch}",
                      })

          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              fail("missing GITHUB_OUTPUT")

          with Path(output_path).open("a", encoding="utf-8") as fh:
              fh.write(
                  "image_tags_json="
                  f"{json.dumps(ordered_tags, separators=(',', ':'))}\n"
              )
              fh.write(
                  "publish_refs_json="
                  f"{json.dumps(publish_refs, separators=(',', ':'))}\n"
              )
          PY

      - name: Log in to GHCR
        if: ${{ needs.discover.outputs.should_publish == 'true' }}
        shell: bash
        env:
          GHCR_TOKEN: ${{ github.token }}
        run: |
          echo "${GHCR_TOKEN}" | podman login ghcr.io --username "${GITHUB_ACTOR}" --password-stdin

      - name: Push amd64 image tags
        if: ${{ needs.discover.outputs.should_publish == 'true' }}
        shell: bash
        env:
          PUBLISH_REFS_JSON: ${{ steps.collect.outputs.publish_refs_json }}
        run: |
          python - <<'PY'
          import json
          import os
          import shlex
          import subprocess

          refs = json.loads(os.environ["PUBLISH_REFS_JSON"])
          if not isinstance(refs, list):
              raise SystemExit("PUBLISH_REFS_JSON must decode to a list")

          for row in refs:
              if not isinstance(row, dict):
                  raise SystemExit("publish ref rows must be objects")
              source_id = row.get("source_id")
              target_ref = row.get("target_ref")
              if not isinstance(source_id, str) or not isinstance(target_ref, str):
                  raise SystemExit("publish ref rows must contain source_id and target_ref")

              tag_cmd = ["podman", "tag", source_id, target_ref]
              print("+", " ".join(shlex.quote(part) for part in tag_cmd))
              subprocess.run(tag_cmd, check=True)

              push_cmd = ["podman", "push", target_ref]
              print("+", " ".join(shlex.quote(part) for part in push_cmd))
              subprocess.run(push_cmd, check=True)
          PY

  build_arm64:
    name: Build arm64 images
    needs: discover
    runs-on: ubuntu-24.04-arm
    outputs:
      image_tags_json: ${{ steps.collect.outputs.image_tags_json }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Bertrand CLI
        shell: bash
        run: |
          python -m venv .venv
          . .venv/bin/activate
          python -m pip install --upgrade pip
          python -m pip install "bertrand=={% endraw %}{{ bertrand_version }}{% raw %}"
          echo "${PWD}/.venv/bin" >> "$GITHUB_PATH"

      - name: Bootstrap toolchain and build images
        shell: bash
        run: |
          bertrand init --yes
          bertrand build .

      - id: collect
        name: Collect arm64 image tags and publish refs
        shell: bash
        env:
          ARCH: arm64
          BASE_TAGS_JSON: ${{ needs.discover.outputs.tags_json }}
          SHOULD_PUBLISH: ${{ needs.discover.outputs.should_publish }}
        run: |
          python - <<'PY'
          import json
          import os
          import subprocess
          from pathlib import Path


          def fail(message: str) -> None:
              raise SystemExit(message)


          def run_capture(cmd: list[str]) -> str:
              cp = subprocess.run(cmd, check=True, capture_output=True, text=True)
              return cp.stdout


          def normalize_list(payload: object, where: str) -> list[object]:
              if isinstance(payload, list):
                  return payload
              fail(f"expected list at {where}")


          ls_raw = run_capture(["bertrand", "ls", ".", "--images", "--json"])
          ls_payload = json.loads(ls_raw)
          ls_rows = normalize_list(ls_payload, "bertrand ls output")

          image_ids: list[str] = []
          seen_ids: set[str] = set()
          for row in ls_rows:
              if not isinstance(row, dict):
                  continue
              image_id = None
              for key in ("Id", "ID", "ImageID", "ImageId"):
                  value = row.get(key)
                  if isinstance(value, str) and value.strip():
                      image_id = value.strip()
                      break
              if image_id is None or image_id in seen_ids:
                  continue
              seen_ids.add(image_id)
              image_ids.append(image_id)

          if not image_ids:
              fail("no Bertrand images were found after build")

          tag_to_id: dict[str, str] = {}
          for image_id in image_ids:
              inspect_raw = run_capture(["podman", "image", "inspect", image_id])
              inspect_payload = json.loads(inspect_raw)
              if isinstance(inspect_payload, list):
                  if not inspect_payload:
                      continue
                  inspect_obj = inspect_payload[0]
              else:
                  inspect_obj = inspect_payload

              if not isinstance(inspect_obj, dict):
                  fail(f"invalid inspect payload for image id: {image_id}")

              labels = inspect_obj.get("Labels")
              if labels is None:
                  labels = {}
              if not isinstance(labels, dict):
                  fail(f"invalid image labels for image id: {image_id}")

              image_tag = labels.get("BERTRAND_IMAGE")
              if not isinstance(image_tag, str):
                  fail(
                      "missing BERTRAND_IMAGE label in inspect data for image id: "
                      f"{image_id}"
                  )

              existing_id = tag_to_id.get(image_tag)
              if existing_id is not None and existing_id != image_id:
                  fail(f"duplicate built image tag detected: '{image_tag}'")
              tag_to_id[image_tag] = image_id

          if not tag_to_id:
              fail("no Bertrand image tags discovered from inspect labels")

          ordered_tags: list[str] = []
          if "" in tag_to_id:
              ordered_tags.append("")
          ordered_tags.extend(sorted(tag for tag in tag_to_id if tag))

          should_publish = os.environ.get("SHOULD_PUBLISH", "false").lower() == "true"
          base_tags = json.loads(os.environ.get("BASE_TAGS_JSON", "[]"))
          if not isinstance(base_tags, list) or not all(isinstance(x, str) for x in base_tags):
              fail("BASE_TAGS_JSON must decode to list[str]")

          repo = f"ghcr.io/{os.environ['GITHUB_REPOSITORY'].lower()}"
          arch = os.environ["ARCH"]

          publish_refs: list[dict[str, str]] = []
          if should_publish:
              for image_tag in ordered_tags:
                  suffix = f"-{image_tag}" if image_tag else ""
                  source_id = tag_to_id[image_tag]
                  for base in base_tags:
                      publish_refs.append({
                          "source_id": source_id,
                          "target_ref": f"{repo}:{base}{suffix}-{arch}",
                      })

          output_path = os.environ.get("GITHUB_OUTPUT")
          if not output_path:
              fail("missing GITHUB_OUTPUT")

          with Path(output_path).open("a", encoding="utf-8") as fh:
              fh.write(
                  "image_tags_json="
                  f"{json.dumps(ordered_tags, separators=(',', ':'))}\n"
              )
              fh.write(
                  "publish_refs_json="
                  f"{json.dumps(publish_refs, separators=(',', ':'))}\n"
              )
          PY

      - name: Log in to GHCR
        if: ${{ needs.discover.outputs.should_publish == 'true' }}
        shell: bash
        env:
          GHCR_TOKEN: ${{ github.token }}
        run: |
          echo "${GHCR_TOKEN}" | podman login ghcr.io --username "${GITHUB_ACTOR}" --password-stdin

      - name: Push arm64 image tags
        if: ${{ needs.discover.outputs.should_publish == 'true' }}
        shell: bash
        env:
          PUBLISH_REFS_JSON: ${{ steps.collect.outputs.publish_refs_json }}
        run: |
          python - <<'PY'
          import json
          import os
          import shlex
          import subprocess

          refs = json.loads(os.environ["PUBLISH_REFS_JSON"])
          if not isinstance(refs, list):
              raise SystemExit("PUBLISH_REFS_JSON must decode to a list")

          for row in refs:
              if not isinstance(row, dict):
                  raise SystemExit("publish ref rows must be objects")
              source_id = row.get("source_id")
              target_ref = row.get("target_ref")
              if not isinstance(source_id, str) or not isinstance(target_ref, str):
                  raise SystemExit("publish ref rows must contain source_id and target_ref")

              tag_cmd = ["podman", "tag", source_id, target_ref]
              print("+", " ".join(shlex.quote(part) for part in tag_cmd))
              subprocess.run(tag_cmd, check=True)

              push_cmd = ["podman", "push", target_ref]
              print("+", " ".join(shlex.quote(part) for part in push_cmd))
              subprocess.run(push_cmd, check=True)
          PY

  manifest:
    name: Publish multi-arch manifests
    needs:
      - discover
      - build_amd64
      - build_arm64
    if: ${{ needs.discover.outputs.should_publish == 'true' }}
    runs-on: ubuntu-24.04
    steps:
      - name: Install Podman
        shell: bash
        run: |
          sudo apt-get update
          sudo apt-get install -y podman

      - name: Log in to GHCR
        shell: bash
        env:
          GHCR_TOKEN: ${{ github.token }}
        run: |
          echo "${GHCR_TOKEN}" | podman login ghcr.io --username "${GITHUB_ACTOR}" --password-stdin

      - name: Assemble and push manifests
        shell: bash
        env:
          BASE_TAGS_JSON: ${{ needs.discover.outputs.tags_json }}
          AMD_IMAGE_TAGS_JSON: ${{ needs.build_amd64.outputs.image_tags_json }}
          ARM_IMAGE_TAGS_JSON: ${{ needs.build_arm64.outputs.image_tags_json }}
        run: |
          python - <<'PY'
          import json
          import os
          import shlex
          import subprocess


          def fail(message: str) -> None:
              raise SystemExit(message)


          base_tags = json.loads(os.environ["BASE_TAGS_JSON"])
          amd_tags = json.loads(os.environ["AMD_IMAGE_TAGS_JSON"])
          arm_tags = json.loads(os.environ["ARM_IMAGE_TAGS_JSON"])

          if not isinstance(base_tags, list) or not all(isinstance(x, str) for x in base_tags):
              fail("BASE_TAGS_JSON must decode to list[str]")
          if not isinstance(amd_tags, list) or not all(isinstance(x, str) for x in amd_tags):
              fail("AMD_IMAGE_TAGS_JSON must decode to list[str]")
          if not isinstance(arm_tags, list) or not all(isinstance(x, str) for x in arm_tags):
              fail("ARM_IMAGE_TAGS_JSON must decode to list[str]")

          if amd_tags != arm_tags:
              fail(
                  "built image tag sets differ between architectures: "
                  f"amd64={amd_tags}, arm64={arm_tags}"
              )

          repo = f"ghcr.io/{os.environ['GITHUB_REPOSITORY'].lower()}"

          for image_tag in amd_tags:
              suffix = f"-{image_tag}" if image_tag else ""
              for base in base_tags:
                  manifest_ref = f"{repo}:{base}{suffix}"
                  source_refs = [
                      f"{manifest_ref}-amd64",
                      f"{manifest_ref}-arm64",
                  ]

                  subprocess.run(
                      ["podman", "manifest", "rm", manifest_ref],
                      check=False,
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL,
                  )

                  create_cmd = ["podman", "manifest", "create", manifest_ref]
                  print("+", " ".join(shlex.quote(part) for part in create_cmd))
                  subprocess.run(create_cmd, check=True)

                  for source_ref in source_refs:
                      add_cmd = [
                          "podman",
                          "manifest",
                          "add",
                          manifest_ref,
                          f"docker://{source_ref}",
                      ]
                      print("+", " ".join(shlex.quote(part) for part in add_cmd))
                      subprocess.run(add_cmd, check=True)

                  push_cmd = [
                      "podman",
                      "manifest",
                      "push",
                      "--all",
                      manifest_ref,
                      f"docker://{manifest_ref}",
                  ]
                  print("+", " ".join(shlex.quote(part) for part in push_cmd))
                  subprocess.run(push_cmd, check=True)

                  subprocess.run(
                      ["podman", "manifest", "rm", manifest_ref],
                      check=False,
                      stdout=subprocess.DEVNULL,
                      stderr=subprocess.DEVNULL,
                  )
          PY
{% endraw %}
