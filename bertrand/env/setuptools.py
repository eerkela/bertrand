"""Build tools for bertrand-enabled C++ extensions."""
from __future__ import annotations

import json
import os
import re
import shutil
import subprocess
import sys
import sysconfig
from pathlib import Path
from typing import Any, Iterable, TextIO

import setuptools
from pybind11.setup_helpers import Pybind11Extension
from pybind11.setup_helpers import build_ext as pybind11_build_ext

from .environment import env
from .package import Package, PackageLike


def get_include() -> str:
    """Get the path to the include directory for this package, which is necessary to
    make C++ headers available to the compiler.

    Returns
    -------
    str
        The path to the include directory for this package.
    """
    return str(Path(__file__).absolute().parent.parent.parent)


# TODO: write an AST parser and invoke it in the Extension constructor to detect
# module imports, main() function, and the public interface of the final Python module.


class Extension(Pybind11Extension):
    """A setuptools.Extension class that builds using CMake and supports C++20 modules.

    Parameters
    ----------
    *args, **kwargs : Any
        Arbitrary arguments passed to the Pybind11Extension constructor.
    conan : list[str], optional
        A list of Conan package names to install before building the extension.
    cxx_std : int, default 20
        The C++ standard to use when compiling the extension.  Values less than 20 will
        raise a ValueError.
    traceback : bool, default True
        If set to false, add `BERTRAND_NO_TRACEBACK` to the compile definitions, which
        will disable cross-language tracebacks for the extension.
    extra_cmake_args : dict[str, Any], optional
        Additional arguments to pass to the Extension's CMake configuration.  These are
        emitted as key-value pairs into a `set_target_properties()` block in the
        generated CMakeLists.txt file.  Some options are filled in by default,
        including `PREFIX`, `LIBRARY_OUTPUT_DIRECTORY`, `LIBRARY_OUTPUT_NAME`,
        `SUFFIX`, `CXX_STANDARD`, and `CXX_STANDARD_REQUIRED`.
    """

    MODULE_REGEX = re.compile(r"\s*export\s+module\s+(\w+).*;", re.MULTILINE)
    MAIN_REGEX = re.compile(r"\s*int\s+main\s*\(", re.MULTILINE)

    def __init__(
        self,
        *args: Any,
        cxx_std: int = 23,
        traceback: bool = True,
        extra_cmake_args: dict[str, Any] | None = None,
        **kwargs: Any
    ) -> None:
        if cxx_std < 23:
            raise ValueError(
                "C++ standard must be at least C++23 to enable bertrand features"
            )

        super().__init__(*args, **kwargs)
        self.cxx_std = cxx_std
        self.traceback = traceback
        self.extra_cmake_args = extra_cmake_args or {}
        self.extra_link_args = [sysconfig.get_config_var("LDFLAGS")] + self.extra_link_args

        self.include_dirs.append(get_include())
        # self.include_dirs.append(numpy.get_include())
        if self.traceback:
            self.extra_compile_args.append("-g")
            self.extra_link_args.append("-g")
        else:
            self.define_macros.append(("BERTRAND_NO_TRACEBACK", "ON"))

        self.modules: list[Path] = []
        executables: list[Path] = []
        for source in self.sources:
            path = Path(source)
            with path.open("r", encoding="utf_8") as f:
                content = f.read()
                if self.MODULE_REGEX.search(content):
                    self.modules.append(path)
                if self.MAIN_REGEX.search(content):
                    executables.append(path)

        if len(executables) > 1:
            raise ValueError(
                f"Cannot build extension: multiple main() functions detected in "
                f"{[str(p) for p in executables]}"
            )

        self.executable = executables.pop() if executables else None

    def scan_modules(self) -> dict[str, Any]:
        """Run clang-scan-deps on the sources to extract module dependencies.

        Returns
        -------
        dict[str, Any]
            A dictionary mapping module names to their dependency graph, in p1689r5
            (https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1689r5.html)
            format.  This is the same format that is ultimately used by CMake to
            build the modules.
        """
        return json.loads(subprocess.run(
            [
                str(env / "bin" / "clang-scan-deps"),
                "-format=p1689",
                "--",
                "clang++",
                *self.sources,
                # *self.extra_compile_args,
                # *compile_args
            ],
            check=True,
            capture_output=True,
        ).stdout.decode("utf-8").strip())


class ConanFile:
    """A wrapper around a temporary conanfile.txt file generated by the build system
    when compiling C/C++ extensions.
    """

    def __init__(self, build_lib: Path, packages: list[Package]) -> None:
        self.path = build_lib.absolute() / "conanfile.txt"
        self.packages = packages

        self.path.parent.mkdir(parents=True, exist_ok=True)
        self.path.touch(exist_ok=True)
        with self.path.open("w") as f:
            f.write("[requires]\n")
            for p in self.packages:
                f.write(f"{p.name}/{p.version}\n")
            f.write("\n")
            f.write("[generators]\n")
            f.write("CMakeDeps\n")
            f.write("CMakeToolchain\n")
            f.write("\n")
            f.write("[layout]\n")
            f.write("cmake_layout\n")

    def install(self) -> None:
        """Install the Conan packages listed in the conanfile.txt file and write the
        newly-installed packages to the env.toml file.
        """
        subprocess.check_call(
            [
                "conan",
                "install",
                str(self.path),
                "--build=missing",
                "--output-folder",
                str(self.path.parent),
                "-verror",
            ],
            cwd=self.path.parent
        )
        env.packages.extend(p for p in self.packages if p not in env.packages)



class CMakeLists:
    """A wrapper around a temporary CMakeLists.txt file generated by the build system
    when compiling C/C++ extensions.
    """

    MIN_VERSION = "3.28"  # CMake 3.28+ is necessary for C++20 module support

    class Modules:
        """Manages module dependencies and AST parsing for C++20 modules."""

        def __init__(self, compile_commands: Path) -> None:
            self.commands = compile_commands.parent / "p1689_commands.json"

            # rewrite compile_commands.json file to remove any lazily-evaluated cmake
            # arguments that are not supported by clang-scan-deps
            with self.commands.open("w") as outfile:
                with compile_commands.open("r") as infile:
                    filtered = [
                        {
                            "directory": cmd["directory"],
                            "command": " ".join(
                                c for c in cmd["command"].split() if not c.startswith("@")
                            ),
                            "file": cmd["file"],
                            "output": cmd["output"],
                        }
                        for cmd in json.load(infile)
                    ]
                json.dump(filtered, outfile, indent=4)

            # invoke clang-scan-deps to generate the p1689 dependency graph
            self.p1689 = json.loads(subprocess.run(
                [
                    str(env / "bin" / "clang-scan-deps"),
                    "-format=p1689",
                    "-compilation-database",
                    str(self.commands),
                ],
                check=True,
                capture_output=True,
            ).stdout.decode("utf-8").strip())

            # extract exported C++20 modules and generate equivalent Python bindings
            self.cpp_modules: dict[str, Path] = {}
            self.python_modules: dict[str, Path] = {}
            for module in self.p1689["rules"]:
                for source in module.get("provides", []):
                    name = source["logical-name"]
                    path = Path(source["source-path"])
                    self.cpp_modules[name] = path
                    self.python_modules[name] = self.emit_python(path)

            # fill in unresolved C++20 modules with Python bindings
            for module in self.p1689["rules"]:
                for source in module.get("requires", []):
                    name = source["logical-name"]
                    if name not in self.cpp_modules:
                        self.cpp_modules[name] = path

        def emit_python(self, path: Path) -> Path:
            """Emit a C++ to Python binding file so that the module can a C++20 module
            can be imported from Python.

            Parameters
            ----------
            path : Path
                The path to the C++20 module file to generate a Python binding for.

            Returns
            -------
            Path
                The path to the generated C++ binding file, which can be reused to
                resolve future imports.
            """
            breakpoint()
            raise NotImplementedError("C++ -> Python bindings are not yet supported")

        def emit_cpp(self, module_name: str) -> Path:
            """Emit a Python to C++ binding file for an unresolved C++ import.

            Parameters
            ----------
            module_name : str
                The name of the unresolved C++20 module to generate a binding for.

            Returns
            -------
            Path
                The path to the generated Python binding file, which can be reused to
                resolve future imports.
            """
            breakpoint()
            raise NotImplementedError("Python -> C++ bindings are not yet supported")




    def __init__(
        self,
        build_lib: Path,
        project: str,
        debug: bool,
        include_dirs: list[str] | None = None,
        library_dirs: list[str] | None = None,
        libraries: list[str] | None = None,
    ) -> None:
        build_lib = build_lib.absolute()
        build_type = "Debug" if debug else "Release"

        self.project = project
        self.debug = debug
        self.path = build_lib / "CMakeLists.txt"
        toolchain = (
            build_lib / "build" / build_type / "generators" / "conan_toolchain.cmake"
        )

        self.path.parent.mkdir(parents=True, exist_ok=True)
        self.path.touch(exist_ok=True)
        with self.path.open("w") as f:
            f.write(f"cmake_minimum_required(VERSION {self.MIN_VERSION})\n")
            f.write(f"project({project} LANGUAGES CXX)\n")
            f.write("\n")
            f.write(f"set(CMAKE_BUILD_TYPE {build_type})\n")
            f.write(f"set(PYTHON_EXECUTABLE {sys.executable})\n")
            f.write("set(CMAKE_COLOR_DIAGNOSTICS ON)\n")
            f.write("set(CMAKE_CXX_SCAN_FOR_MODULES ON)\n")
            f.write("set(CMAKE_EXPORT_COMPILE_COMMANDS ON)\n")
            f.write("\n")

            f.write(f"include({toolchain})\n")
            for package in env.packages:
                f.write(f"find_package({package.find} REQUIRED)\n")

            if include_dirs:
                f.write("include_directories(\n")
                for include in include_dirs:
                    f.write(f"    {include}\n")
                f.write(")\n")

            if library_dirs:
                f.write("link_directories(\n")
                for lib_dir in library_dirs:
                    f.write(f"    {lib_dir}\n")
                f.write(")\n")

            if libraries:
                f.write("link_libraries(\n")
                for lib in libraries:
                    f.write(f"    {lib}\n")
                f.write(")\n")

            f.write("\n")

    def _target_sources(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_sources({target} PRIVATE\n")
        f.write( "    FILE_SET CXX_MODULES\n")
        f.write(f"    BASE_DIRS {Path.cwd()}\n")
        f.write( "    FILES\n")
        for source in ext.modules:
            f.write(f"        {Path(source).absolute()}\n")
        f.write(")\n")

    def _target_include_directories(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_include_directories({target} PRIVATE\n")
        for include in ext.include_dirs:
            f.write(f"    {include}\n")
        f.write(")\n")

    def _target_link_directories(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_link_directories({target} PRIVATE\n")
        for lib_dir in ext.library_dirs:
            f.write(f"    {lib_dir}\n")
        f.write(")\n")

    def _target_link_libraries(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_link_libraries({target} PRIVATE\n")
        for lib in ext.libraries:
            f.write(f"    {lib}\n")
        f.write(")\n")

    def _target_compile_options(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_compile_options({target} PRIVATE\n")
        for flag in ext.extra_compile_args:
            f.write(f"    {flag}\n")
        f.write(")\n")

    def _target_link_options(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_link_options({target} PRIVATE\n")
        for flag in ext.extra_link_args:
            f.write(f"    {flag}\n")
        f.write(")\n")

    def _target_compile_definitions(self, f: TextIO, target: str, ext: Extension) -> None:
        f.write(f"target_compile_definitions({target} PRIVATE\n")
        for define in ext.define_macros:
            f.write(f"    {define[0]}={define[1]}\n")
        f.write(")\n")

    def _add_library(self, target: str, ext: Extension) -> None:
        with self.path.open("a") as f:
            f.write(f"add_library({target} MODULE\n")
            for source in ext.sources:
                f.write(f"    {Path(source).absolute()}\n")
            f.write(")\n")
            f.write(f"set_target_properties({target} PROPERTIES\n")
            f.write( "    PREFIX \"\"\n")
            f.write(f"    OUTPUT_NAME {target}\n")
            f.write( "    SUFFIX \"\"\n")
            f.write(f"    CXX_STANDARD {ext.cxx_std}\n")
            f.write( "    CXX_STANDARD_REQUIRED ON\n")
            for key, value in ext.extra_cmake_args.items():
                f.write(f"    {key} {value}\n")
            f.write(")\n")
            if ext.modules:
                self._target_sources(f, target, ext)
            if ext.include_dirs:
                self._target_include_directories(f, target, ext)
            if ext.library_dirs:
                self._target_link_directories(f, target, ext)
            if ext.libraries:
                self._target_link_libraries(f, target, ext)
            if ext.extra_compile_args:
                self._target_compile_options(f, target, ext)
            if ext.extra_link_args:
                self._target_link_options(f, target, ext)
            if ext.define_macros:
                self._target_compile_definitions(f, target, ext)
            f.write("\n")

    def _add_executable(self, target: str, ext: Extension) -> None:
        with self.path.open("a") as f:
            f.write(f"add_executable({target}\n")
            for source in ext.sources:
                f.write(f"    {Path(source).absolute()}\n")
            f.write(")\n")
            f.write(f"set_target_properties({target} PROPERTIES\n")
            f.write( "    PREFIX \"\"\n")
            f.write(f"    OUTPUT_NAME {target}\n")
            f.write( "    SUFFIX \"\"\n")
            f.write(f"    CXX_STANDARD {ext.cxx_std}\n")
            f.write( "    CXX_STANDARD_REQUIRED ON\n")
            for key, value in ext.extra_cmake_args.items():
                f.write(f"    {key} {value}\n")
            f.write(")\n")
            if ext.modules:
                self._target_sources(f, target, ext)
            if ext.include_dirs:
                self._target_include_directories(f, target, ext)
            if ext.library_dirs:
                self._target_link_directories(f, target, ext)
            if ext.libraries:
                self._target_link_libraries(f, target, ext)
            if ext.extra_compile_args:
                self._target_compile_options(f, target, ext)
            if ext.extra_link_args:
                self._target_link_options(f, target, ext)
            if ext.define_macros:
                self._target_compile_definitions(f, target, ext)
            f.write("\n")

    def add(self, ext: Extension) -> None:
        """Add an extension to the CMakeLists.txt file.

        Parameters
        ----------
        ext : Extension
            An extension describing the library and/or executable to add.
        """
        self._add_library(f"{ext.name}{sysconfig.get_config_var('EXT_SUFFIX')}", ext)
        if ext.executable:
            self._add_executable(ext.name, ext)

    def install(self, workers: int) -> None:
        """Invoke CMake to build the project.

        Parameters
        ----------
        workers : int
            The number of parallel workers to use when building the project.
        """
        # preconfigure to emit compile_commands.json
        subprocess.check_call(
            [
                "cmake",
                "-G",
                "Ninja",
                str(self.path.parent),
            ],
            cwd=self.path.parent,
            stdout=subprocess.PIPE,  # NOTE: silences noisy CMake/Conan output
        )

        # TODO: it's possible to build a dependency graph by inserting --graphviz=filepath
        # into this step.  This could be useful for debugging or for visualizing the
        # build process.  It could generate some wicked art, too.

        # build module database using clang-scan-deps
        # modules = CMakeLists.Modules(self.path.parent / "compile_commands.json")

        # build the extensions using CMake
        try:
            build_args = [
                "cmake",
                "--build",
                ".",
                "--config",
                "Debug" if self.debug else "Release",
            ]
            if workers:
                build_args += ["--parallel", str(workers)]
            subprocess.check_call(build_args, cwd=self.path.parent)
        except subprocess.CalledProcessError:
            sys.exit()  # errors are already printed to the console

        # copy the compile_commands.json file to the source directory so that it can
        # be picked up by clangd, etc.
        shutil.copy2(self.path.parent / "compile_commands.json", "compile_commands.json")


class BuildExt(pybind11_build_ext):
    """A custom build_ext command that uses CMake to build extensions with support for
    C++20 modules, parallel builds, clangd, executable targets, and bertrand's core
    dependencies without any extra configuration.
    """

    user_options = pybind11_build_ext.user_options + [
        (
            "workers=",
            "j",
            "The number of parallel workers to use when building CMake extensions"
        )
    ]

    def __init__(self, *args: Any, conan: list[Package], workers: int, **kwargs: Any) -> None:
        super().__init__(*args, **kwargs)
        self.conan = conan
        self.workers = workers

    def finalize_options(self) -> None:
        """Parse command-line options and convert them to the appropriate types.

        Raises
        ------
        ValueError
            If the workers option is not set to a positive integer or 0.
        """
        super().finalize_options()

        if self.workers:
            self.workers = int(self.workers)
            if self.workers == 0:
                self.workers = os.cpu_count() or 1
            elif self.workers < 0:
                raise ValueError(
                    "workers must be set to a positive integer or 0 to use all cores"
                )

    def build_extensions(self) -> None:
        """Build all extensions in the project.

        Raises
        ------
        RuntimeError
            If setup.py is invoked outside of a bertrand virtual environment.
        """
        if self.extensions and "BERTRAND_HOME" not in os.environ:
            raise RuntimeError(
                "setup.py must be run inside a bertrand virtual environment in order "
                "to compile C++ extensions"
            )

        self.check_extensions_list(self.extensions)
        build_lib = Path(self.build_lib)

        if self.conan:
            ConanFile(build_lib, self.conan).install()
        packages = list(env.packages)

        cmakelists = CMakeLists(
            build_lib=Path(self.build_lib),
            project=self.distribution.get_name(),
            debug=self.debug,
            include_dirs=self.compiler.include_dirs,
            library_dirs=self.compiler.library_dirs,
            libraries=self.compiler.libraries,
        )
        for ext in self.extensions:
            ext.libraries.extend(p.link for p in packages)
            if isinstance(ext, Extension):
                cmakelists.add(ext)
            else:
                super().build_extension(ext)  # TODO: disallow this?

        cmakelists.install(self.workers)

    def copy_extensions_to_source(self) -> None:
        """Copy executables as well as shared libraries to the source directory if
        setup.py was invoked with the --inplace option.
        """
        for ext in self.extensions:
            lib_path = Path(self.build_lib) / f"{ext.name}{sysconfig.get_config_var('EXT_SUFFIX')}"
            exe_path = Path(self.build_lib) / ext.name
            if lib_path.exists():
                self.copy_file(
                    lib_path,
                    self.get_ext_fullpath(ext.name),
                    level=self.verbose,  # type: ignore
                )
            if exe_path.exists():
                new_path = Path(self.get_ext_fullpath(ext.name)).parent
                idx = ext.name.rfind(".")
                if idx < 0:
                    new_path /= ext.name
                else:
                    new_path /= ext.name[idx + 1:]
                self.copy_file(exe_path, new_path, level=self.verbose)  # type: ignore


def setup(
    *args: Any,
    cmdclass: dict[str, Any] | None = None,
    conan: Iterable[PackageLike] | None = None,
    workers: int = 0,
    **kwargs: Any
) -> None:
    """A custom setup() function that automatically appends the BuildExt command to the
    setup commands.

    Parameters
    ----------
    *args : Any
        Arbitrary positional arguments passed to the setuptools.setup() function.
    cmdclass : dict[str, Any] | None, default None
        A dictionary of command classes to override the default setuptools commands.
        If no setting is given for "build_ext", then it will be set to
        bertrand.setuptools.BuildExt.
    conan : Iterable[PackageLike] | None, default None
        A list of C++ dependencies to install before building the extensions.  Each
        dependency should be specified as a string of the form
        `{name}/{version}@{find_package}/{target_link_libraries}`, where the
        `find_package` and `target_link_libraries` symbols are passed to the CMake
        commands of the same name.  These identifiers can typically be found by running
        `conan search ${package_name}` or by browsing conan.io.
    workers : int, default 0
        The number of parallel workers to use when building extensions.  If set to
        zero, then the build will use all available cores.  This can also be set
        through the command line by supplying either `--workers=n` or `-j n`.
    **kwargs : Any
        Arbitrary keyword arguments passed to the setuptools.setup() function.
    """
    cpp_deps: list[Package] = []
    if env:
        cpp_deps.extend(env.packages)

    for p in conan or []:
        package = Package(p, allow_shorthand=False)
        if package not in cpp_deps:
            cpp_deps.append(package)

    # cpp_deps = [Package(p, allow_shorthand=False) for p in conan or []]
    class _BuildExtWrapper(BuildExt):
        def __init__(self, *a: Any, **kw: Any):
            super().__init__(*a, conan=cpp_deps, workers=workers, **kw)

    if cmdclass is None:
        cmdclass = {"build_ext": _BuildExtWrapper}
    elif "build_ext" not in cmdclass:
        cmdclass["build_ext"] = _BuildExtWrapper
    else:
        cmd: type = cmdclass["build_ext"]
        if issubclass(cmd, BuildExt):
            class _BuildExtSubclassWrapper(cmd):
                def __init__(self, *a: Any, **kw: Any):
                    super().__init__(*a, conan=cpp_deps, workers=workers, **kw)
            cmdclass["build_ext"] = _BuildExtSubclassWrapper

    setuptools.setup(*args, cmdclass=cmdclass, **kwargs)
