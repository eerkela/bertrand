#ifndef BERTRAND_ITER_JOIN_H
#define BERTRAND_ITER_JOIN_H

#include "bertrand/iter/range.h"


namespace bertrand {


namespace impl {
    struct join_tag {};

    template <typename>
    constexpr bool range_reverse_iterable = false;
    template <typename... A> requires ((!meta::range<A> || meta::reverse_iterable<A>) && ...)
    constexpr bool range_reverse_iterable<meta::pack<A...>> = true;

    /* Given a pack of types `A...`, find all indices in `A...` that correspond to
    ranges, and generate a matching index sequence. */
    template <typename out, size_t, typename...>
    struct _range_indices { using type = out; };
    template <size_t... Is, size_t I, typename T, typename... Ts>
    struct _range_indices<std::index_sequence<Is...>, I, T, Ts...> :
        _range_indices<std::index_sequence<Is...>, I + 1, Ts...>
    {};
    template <size_t... Is, size_t I, meta::range T, typename... Ts>
    struct _range_indices<std::index_sequence<Is...>, I, T, Ts...> :
        _range_indices<std::index_sequence<Is..., I>, I + 1, Ts...>
    {};
    template <meta::not_rvalue... A>
    using range_indices = _range_indices<std::index_sequence<>, 0, A...>::type;

    /* Given a pack of `impl::subrange` types `Subranges...` and an aligned index
    sequence generated by `range_indices`, find the common iterator category and
    difference type for all subranges that correspond to ranges in the original
    `A...` pack. */
    template <typename, typename...>
    struct join_traits;
    template <size_t... Is, typename... Subranges>
    struct join_traits<std::index_sequence<Is...>, Subranges...> {
        using category = meta::common_type<
            meta::iterator_category<meta::unpack_type<Is, Subranges...>>...
        >;
        using difference = meta::common_type<
            meta::iterator_difference<meta::unpack_type<Is, Subranges...>>...
        >;
    };

    /// TODO: figure out flattening?
    /// -> There should be a way to distinguish:
    ///
    ///     range{List{Str("ab"), Str("bc"), Str("cd")}} ->* join{Str(".")}
    ///         => ["ab", ".", "bc", ".", "cd"]
    ///     range{List{Str("ab"), Str("bc"), Str("cd")}} ->* join{Str(".")}
    ///         => ["a", "b", ".", "b", "c", ".", "c", "d"]
    ///
    /// Maybe the best way to do this is to encode it in the separators?  You could
    /// use an empty separator to force an extra layer of recursion, and the algorithm
    /// would only flatten to the depth specified by the separators.  So the second
    /// option would be given by:
    ///
    ///     range{List{Str("ab"), Str("bc"), Str("cd")}} ->* join{Str("."), None}
    ///         => ["a", "b", ".", "b", "c", ".", "c", "d"]
    ///
    /// Reversing the order of `Str(".")` and `None` would yield the following instead:
    ///
    ///     range{List{Str("ab"), Str("bc"), Str("cd")}} ->* join{None, Str(".")}
    ///         => ["a", ".", "b", ".", "b", ".", "c", ".", "c", ".", "d"]
    ///
    /// Using the first syntax without `None` yields the original (most
    /// straightforward) behavior:
    /// 
    ///     range{List{Str("ab"), Str("bc"), Str("cd")}} ->* join{Str(".")}
    ///         => ["ab", ".", "bc", ".", "cd"]




    /// TODO: I need to break `join` into two separate classes: `concat` and `join`.
    /// `concat` will take multiple arguments, but only one separator (defaulting to
    /// trivial), and `join` will take multiple separators but only one argument.
    /// In order to replicate the current behavior and do both, one would stack them
    /// like so:
    ///
    ///     join{sep1, sep2, ...}(concat{sep0}(arg1, arg2, ...));



    struct join_forward {};
    struct join_reverse {};

    template <typename T>
    concept join_direction = std::same_as<T, join_forward> || std::same_as<T, join_reverse>;

    template <size_t I>
    concept join_depth = I > 0;

    template <meta::not_reference Outer, join_direction Dir>
    struct join_iterator;
    template <meta::not_reference Outer, join_direction Dir, size_t Depth, meta::not_rvalue Value>
        requires (join_depth<Depth>)
    struct join_subrange;

    template <typename T>
    constexpr bool _is_join_iterator = false;
    template <typename Outer, typename Dir>
    constexpr bool _is_join_iterator<join_iterator<Outer, Dir>> = true;
    template <typename T>
    concept is_join_iterator = _is_join_iterator<meta::unqualify<T>>;

    template <typename T>
    constexpr bool _is_join_subrange = false;
    template <typename Outer, typename Dir, size_t Depth, typename Value>
    constexpr bool _is_join_subrange<join_subrange<Outer, Dir, Depth, Value>> = true;
    template <typename T>
    concept is_join_subrange = _is_join_subrange<meta::unqualify<T>>;

    /* Get an appropriate begin iterator to store within a `join_subrange` block based
    on its direction.  The rest of the logic is identical for both options. */
    template <join_direction Dir, typename T>
    [[nodiscard]] constexpr auto join_begin(T& value)
        noexcept (std::same_as<Dir, join_forward> ?
            requires{{meta::begin(value)} noexcept;} :
            requires{{meta::rbegin(value)} noexcept;}
        )
        requires (
            (std::same_as<Dir, join_forward> && requires{{meta::begin(value)};}) ||
            (std::same_as<Dir, join_reverse> && requires{{meta::rbegin(value)};})
        )
    {
        if constexpr (std::same_as<Dir, join_forward>) {
            return meta::begin(value);
        } else {
            return meta::rbegin(value);
        }
    }

    /* Get an appropriate end iterator to store within a `join_subrange` block based
    on its direction.  The rest of the logic is identical for both options. */
    template <join_direction Dir, typename T>
    [[nodiscard]] constexpr auto join_end(T& value)
        noexcept (std::same_as<Dir, join_forward> ?
            requires{{meta::end(value)} noexcept;} :
            requires{{meta::rend(value)} noexcept;}
        )
        requires (
            (std::same_as<Dir, join_forward> && requires{{meta::end(value)};}) ||
            (std::same_as<Dir, join_reverse> && requires{{meta::rend(value)};})
        )
    {
        if constexpr (std::same_as<Dir, join_forward>) {
            return meta::end(value);
        } else {
            return meta::rend(value);
        }
    }

    /* Cast the internal union of a `join_subrange` or `join_iterator` to the
    alternative encoded at index `I`.  Note that if a separator is present at the
    current level, then odd indices will map to that separator, while even indices will
    map to an argument in the outer `join` signature or a yield type thereof. */
    template <size_t I, typename T> requires (I < T::alternatives)
    constexpr decltype(auto) join_get(T& self)
        noexcept (I < T::unique_alternatives ?
            requires{{impl::visitable<decltype((*self.child))>::template get<
                T::template alternative<I>
            >(*self.child)} noexcept;} :
            requires{{impl::visitable<decltype((*self.child))>::template get<
                T::template alternative<I>
            >(*self.child)};}
        )
    {
        return (impl::visitable<decltype((*self.child))>::template get<
            T::template alternative<I>
        >(*self.child));
    }

    /* Invoke a vtable function on a `join_subrange` or `join_iterator` object,
    effectively promoting its index into a compile-time constant (modulo `N`).
    `join_get<I>(self)` can then be used to access the proper alternative, assuming `N`
    is equal to the total number of alternatives. */
    template <template <size_t> typename F, typename T, typename... A>
    constexpr decltype(auto) join_visit(T& self, A&&... args)
        noexcept (requires{{impl::basic_vtable<F, T::alternatives>{self.index % T::alternatives}(
            self,
            std::forward<A>(args)...
        )} noexcept;})
        requires (requires{{impl::basic_vtable<F, T::alternatives>{self.index % T::alternatives}(
            self,
            std::forward<A>(args)...
        )};})
    {
        return (impl::basic_vtable<F, T::alternatives>{self.index % T::alternatives}(
            self,
            std::forward<A>(args)...
        ));
    }

    /* Dereferencing a join iterator does not depend on the exact index, just the
    unique alternative. */
    template <typename T>
    struct join_deref {
        template <size_t I>
        struct fn {
            template <typename U>
            static constexpr T operator()(const U& u)
                noexcept (requires{
                    {impl::visitable<const U&>::template get<I>(u).template deref<T>()} noexcept;
                })
            {
                return impl::visitable<const U&>::template get<I>(u).template deref<T>();
            }
        };
    };

    /* Comparing two join iterators first compares their indices, and only invokes the
    vtable function if they happen to match, meaning that it can get away with using
    unique alternatives, and forcing the argument types to match exactly. */
    template <size_t I>
    struct join_compare {
        template <typename U>
        static constexpr std::strong_ordering operator()(const U& lhs, const U& rhs)
            noexcept (requires{{
                impl::visitable<const U&>::template get<I>(lhs) <=>
                impl::visitable<const U&>::template get<I>(rhs)
            } noexcept;})
        {
            return
                impl::visitable<const U&>::template get<I>(lhs) <=>
                impl::visitable<const U&>::template get<I>(rhs);
        }
    };

    /* Incrementing a join iterator recurs down to the innermost subrange and
    increments the corresponding begin iterator, which is guaranteed not to be empty by
    the time this visitor is called.  If that causes the begin iterator to compare
    equal to its end iterator, then it will return `false` and the parent will advance
    to the next non-empty subrange, assuming one exists.  If not, then the `false`
    signal will be propagated up to the caller, following a depth-first search. */
    template <size_t I>
    struct join_increment {
        template <typename T>
        static constexpr size_t round = T::trivial ? I + 1 : (I | 1) + 1;
        template <typename T>
        static constexpr size_t norm = round<T> / (1 + !T::trivial);

        template <is_join_iterator T, typename Outer>
        static constexpr void skip(T& self, Outer& outer)
            noexcept (round<T> < T::alternatives ?
                requires(decltype(self.template arg<norm<T>>(outer)) next) {
                    {next.begin != next.end} noexcept -> meta::nothrow::truthy;
                    {self.child = self.template arg<norm<T>>(outer)} noexcept;
                    {join_increment<round<T>>::skip(self, outer)} noexcept;
                } :
                requires{{self.child = None} noexcept;}
            )
        {
            if constexpr (round<T> < T::alternatives) {
                self.index = round<T>;
                if (
                    auto next = self.template arg<norm<T>>(outer);
                    next.begin != next.end
                ) {
                    self.child = std::move(next);
                } else {
                    join_increment<round<T>>::skip(self, outer);
                }
            } else {
                self.index = T::alternatives;
                self.child = None;
            }
        }

        template <is_join_subrange T, typename Outer>
        static constexpr void skip(T& self, Outer& outer)
            noexcept (requires(decltype(self.template arg(outer)) next) {
                {next.begin != next.end} noexcept -> meta::nothrow::truthy;
                {self.child = self.template arg(outer)} noexcept;
                {++self.begin} noexcept;
                {self.begin != self.end} noexcept -> meta::nothrow::truthy;
                {self.child = None} noexcept;
            })
        {
            do {
                if (auto next = self.template arg(outer); next.begin != next.end) {
                    self.child = std::move(next);
                    return;
                }
                ++self.begin;
                self.index += 1 + !T::trivial;
            } while (self.begin != self.end);
            self.child = None;
        }

        template <typename T, typename Outer>
        static constexpr bool operator()(T& self, Outer& outer)
            noexcept (requires{
                {join_get<I>(self).increment(outer)} noexcept;
                {skip(self, outer)} noexcept;
            } && (I % 2 != 0 || (
                (!is_join_subrange<T> || requires{
                    {++self.begin} noexcept;
                    {self.begin == self.end} noexcept -> meta::nothrow::truthy;
                    {self.child = None} noexcept;
                }) && (T::trivial || I + 1 >= T::alternatives || requires{
                    {self.child = self.sep(outer)} noexcept;
                })
            )))
        {
            if (join_get<I>(self).increment(outer)) {
                return true;
            }
            ++self.index;
            if constexpr (I % 2 == 0) {
                if constexpr (is_join_subrange<T>) {
                    ++self.begin;
                    if (self.begin == self.end) {
                        self.child = None;
                        return false;
                    }
                }
                if constexpr (!T::trivial && I + 1 < T::alternatives) {
                    if (outer.sep_size[T::depth] != 0) {
                        self.child = self.sep(outer);
                        return true;
                    }
                    ++self.index;
                }
            }
            skip(self, outer);
            return self.child != None;
        }

        /// TODO: random-access increment with mutable `n`, which works mostly the
        /// same way as above, but needs to linearly scan over the intermediate
        /// subranges until `n` is exhausted.  Separators can be skipped over as long
        /// as `n` is greater than the separator size at that level.


        // template <typename T, typename Outer>
        // static constexpr bool operator()(T& self, Outer& outer, ssize_t& n)
        //     noexcept (requires{{join_get<I>(self).increment(outer, n)} noexcept;})
        // {
        //     if (join_get<I>(self).increment(outer, n)) {
        //         return true;
        //     }
        //     /// TODO: similar to above, but lock that in before proceeding.  I may need
        //     /// to recursively call future specializations of `join_increment` in order
        //     /// to implement this.
        // }
    };

    /* Decrementing a join iterator recurs down to the innermost subrange and
    decrements the corresponding begin iterator, which is guaranteed not to be empty by
    the time this visitor is called.  If that causes its index to become negative, then
    it will return `false` and the parent will retreat to the previous non-empty
    subrange, assuming one exists.  If not, then the `false` signal will be propagated
    up to the caller, following a depth-first search. */
    template <size_t I>
    struct join_decrement {
        template <typename T, typename Outer>
        static constexpr bool operator()(T& self, Outer& outer)
            noexcept (requires{{join_get<I>(self).decrement(outer)} noexcept;})
        {
            if (!join_get<I>(self).decrement(outer)) {
                /// TODO: same idea as join_increment
            }
            return true;
        }
        template <typename T, typename Outer>
        static constexpr bool operator()(T& self, Outer& outer, ssize_t& n)
            noexcept (requires{{join_get<I>(self).decrement(outer, n)} noexcept;})
        {
            if (!join_get<I>(self).decrement(outer, n)) {
                /// TODO: same idea as join_increment
            }
            return true;
        }
    };

    /* Getting the distance between two join iterators equates to finding the distance
    between the leftmost subrange's begin and end iterators, and then initializing the
    next subrange for the parent and summing until the parent indices equalize.  Then,
    the last iteration adds the distance from the start of the equalized subrange to
    the current position, and negates the result if the iterators are given in reverse
    order. */
    template <size_t I>
    struct join_distance {
        template <typename T, typename Outer>
        static constexpr void operator()(Outer& outer, const T& self, const T& other)
            noexcept (requires{
                {join_get<I>(self).distance(outer, join_get<I>(other))} noexcept;
            })
        {
            /// TODO: distance is a lot more complicated than increment/decrement, I
            /// remember that much.
            join_get<I>(self).distance(outer, join_get<I>(other));
        }
    };

    template <typename Value, typename T>
    struct _join_wrap { using type = impl::scalar_range<T>; };
    template <meta::range Value, typename T> requires (!meta::range<T>)
    struct _join_wrap<Value, T> { using type = iter::range<T>; };
    template <meta::range Value, meta::range T>
    struct _join_wrap<Value, T> { using type = T; };
    template <typename Value, typename T = Value>
    using join_wrap = _join_wrap<Value, T>::type;

    template <typename>
    struct _join_category;
    template <typename... U>
    struct _join_category<meta::pack<U...>> {
        using type = meta::common_type<typename meta::remove_reference<U>::category...>;
    };
    template <typename U>
    using join_category = _join_category<typename impl::visitable<const U&>::alternatives>::type;

    template <typename>
    struct _join_reference;
    template <typename... U>
    struct _join_reference<meta::pack<U...>> {
        using type = meta::concat<typename meta::remove_reference<U>::reference...>;
    };
    template <typename U>
    using join_reference = _join_reference<typename impl::visitable<const U&>::alternatives>::type;

    /* All join iterators except the first store an optional struct containing the
    parent value for the current iteration (possibly a reference), a subrange over
    that value, and a child union of nested iterators (unless there are no more
    separators).  The first iterator does not store a parent, but does store a child
    union, where each alternative represents either an outer argument or a top-level
    separator. */
    template <meta::not_reference Outer, join_direction Dir, size_t Depth, meta::not_rvalue Value>
        requires (join_depth<Depth>)
    struct join_subrange {
        static constexpr size_t depth = Depth;
        using direction = Dir;
        using begin_type = decltype(join_begin<Dir>(std::declval<meta::as_lvalue<Value>>()));
        using end_type = decltype(join_end<Dir>(std::declval<meta::as_lvalue<Value>>()));
        using category = meta::iterator_category<begin_type>;
        using reference = meta::pack<meta::dereference_type<const begin_type&>>;
        static constexpr bool trivial = true;

        [[no_unique_address]] Value value;
        [[no_unique_address]] begin_type begin;
        [[no_unique_address]] end_type end;
        [[no_unique_address]] ssize_t index = 0;

        [[nodiscard]] constexpr join_subrange(
            Outer& outer,
            meta::forward<Value> value,
            join_forward
        )
            noexcept (requires{
                {Value(std::forward<Value>(value))} noexcept;
                {join_begin<Dir>(this->value)} noexcept;
                {join_end<Dir>(this->value)} noexcept;
            })
            requires (requires{
                {Value(std::forward<Value>(value))};
                {join_begin<Dir>(this->value)};
                {join_end<Dir>(this->value)};
            })
        :
            value(std::forward<Value>(value)),
            begin(join_begin<Dir>(this->value)),
            end(join_end<Dir>(this->value))
        {}

        [[nodiscard]] constexpr join_subrange(
            Outer& outer,
            meta::forward<Value> value,
            join_reverse
        )
            noexcept (requires{
                {Value(std::forward<Value>(value))} noexcept;
                {join_begin<Dir>(this->value)} noexcept;
                {join_end<Dir>(this->value)} noexcept;
            } && (!meta::has_ssize<Value> || requires{
                {begin += meta::ssize(this->value) - 1} noexcept;
            }))
            requires (requires{
                {Value(std::forward<Value>(value))};
                {join_begin<Dir>(this->value)};
                {join_end<Dir>(this->value)};
            } && (!meta::has_ssize<Value> || requires{
                {begin += meta::ssize(this->value) - 1};
            }))
        :
            value(std::forward<Value>(value)),
            begin(join_begin<Dir>(this->value)),
            end(join_end<Dir>(this->value))
        {
            if (begin != end) {
                if constexpr (meta::has_ssize<Value>) {
                    auto size = meta::ssize(this->value) - 1;
                    begin += size;
                    index = size;
                } else {
                    begin_type it = begin;
                    ++it;
                    while (it != end) {
                        ++it;
                        ++begin;
                        ++index;
                    }
                }
            }
        }

        template <typename T>
        [[nodiscard]] constexpr T deref() const
            noexcept (requires{{*begin} noexcept -> meta::nothrow::convertible_to<T>;})
            requires (requires{{*begin} -> meta::convertible_to<T>;})
        {
            return *begin;
        }

        [[nodiscard]] constexpr bool increment(Outer& outer)
            noexcept (requires{{++begin} noexcept;})
        {
            ++begin;
            ++index;
            return begin != end;
        }

        [[nodiscard]] constexpr bool increment(Outer& outer, ssize_t& n)
            noexcept (requires{
                {end - begin} noexcept -> meta::nothrow::convertible_to<ssize_t>;
                {begin += n} noexcept;
            })
            requires (requires{
                {end - begin} -> meta::convertible_to<ssize_t>;
                {begin += n};
            })
        {
            ssize_t remaining = end - begin;
            if (n < remaining) {
                begin += n;
                index += n;
                n = 0;
                return true;
            }
            begin += remaining;
            n -= remaining;
            index += remaining;
            return false;
        }

        [[nodiscard]] constexpr bool decrement(Outer& outer)
            noexcept (requires{{--begin} noexcept;})
            requires (requires{{--begin};})
        {
            --begin;
            --index;
            return index >= 0;
        }

        [[nodiscard]] constexpr bool decrement(Outer& outer, ssize_t& n)
            noexcept (requires{{begin -= n} noexcept;})
            requires (requires{{begin -= n};})
        {
            if (n < index) {
                begin -= n;
                index -= n;
                n = 0;
                return true;
            }
            begin -= index;
            n -= index;
            index = 0;
            return false;
        }

        [[nodiscard]] constexpr ssize_t distance(Outer& outer, const join_subrange& other) const
            noexcept
        {
            return index - other.index;
        }

        [[nodiscard]] constexpr std::strong_ordering operator<=>(const join_subrange& other) const
            noexcept
        {
            return index <=> other.index;
        }
    };
    template <meta::not_reference Outer, join_direction Dir, size_t Depth, meta::not_rvalue Value>
        requires (join_depth<Depth> && Depth < Outer::sep_type::size())
    struct join_subrange<Outer, Dir, Depth, Value> {
        static constexpr size_t depth = Depth;
        using begin_type = decltype(join_begin<Dir>(std::declval<meta::as_lvalue<Value>>()));
        using end_type = decltype(join_end<Dir>(std::declval<meta::as_lvalue<Value>>()));
        using child_type = join_subrange<
            Outer,
            Dir,
            depth + 1,
            join_wrap<Value, meta::dereference_type<const begin_type&>>
        >;
        using separator = join_subrange<
            Outer,
            Dir,
            Outer::sep_type::size(),
            decltype((std::declval<Outer&>().seps.template get<depth>()))
        >;
        static constexpr bool trivial = requires(Outer& outer) {
            {outer.seps.template get<depth>()} -> meta::is<impl::scalar_range<impl::join_tag>>;
        };
        using unique =
            std::conditional_t<trivial, child_type, meta::make_union<separator, child_type>>;
        using category = meta::common_type<
            meta::iterator_category<begin_type>,
            join_category<unique>
        >;
        using reference = join_reference<unique>;
        static constexpr size_t alternatives = 1 + !trivial;
        static constexpr size_t unique_alternatives = impl::visitable<unique>::alternatives::size();

        template <size_t I> requires (I < alternatives)
        static constexpr size_t alternative = I == 1 && unique_alternatives == 2;

        [[no_unique_address]] Value value;
        [[no_unique_address]] begin_type begin;
        [[no_unique_address]] end_type end;
        [[no_unique_address]] ssize_t index = 0;
        [[no_unique_address]] Optional<unique> child;

        template <join_direction D = join_forward> requires (!trivial)
        [[nodiscard]] constexpr auto sep(Outer& outer)
            noexcept (requires{
                {separator{outer, outer.seps.template get<depth>(), D{}}} noexcept;
            })
        {
            return separator{outer, outer.seps.template get<depth>(), D{}};
        }

        template <size_t I = 0, join_direction D = join_forward> requires (I == 0)
        [[nodiscard]] constexpr auto arg(Outer& outer)
            noexcept (requires{{child_type{outer, *begin, D{}}} noexcept;})
        {
            return child_type{outer, *begin, D{}};
        }

    private:
        constexpr Optional<unique> forward_init(Outer& outer)
            noexcept (requires(child_type child) {
                {begin == end} noexcept -> meta::nothrow::truthy;
                {begin != end} noexcept -> meta::nothrow::truthy;
                {arg(outer)} noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
                {child.begin != child.end} noexcept -> meta::nothrow::truthy;
                {++begin} noexcept;
            } && (!trivial || requires{
                {sep(outer)} noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
            }))
        {
            if (begin == end) {
                return None;
            }
            if (auto first = arg(outer); first.begin != first.end) {
                return std::move(first);
            }
            if constexpr (!trivial) {
                ++index;
                if (outer.sep_size[depth] != 0) {
                    return sep(outer);
                }
            }
            ++index;
            ++begin;
            while (begin != end) {
                if (auto next = arg(outer); next.begin != next.end) {
                    return std::move(next);
                }
                index += 1 + !trivial;
                ++begin;
            }
            return None;
        }

        constexpr Optional<unique> reverse_init(Outer& outer)
            noexcept (requires(child_type child) {
                {begin == end} noexcept -> meta::nothrow::truthy;
                {
                    arg<join_reverse>(outer)
                } noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
                {child.begin != child.end} noexcept -> meta::nothrow::truthy;
                {--begin} noexcept;
            } && (!trivial || requires{
                {
                    sep<join_reverse>(outer)
                } noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
            }) && (
                (meta::has_ssize<Value> && requires(meta::ssize_type<Value> size) {
                    {meta::ssize(this->value) - 1} noexcept;
                    {begin += size} noexcept;
                }) ||
                (!meta::has_ssize<Value> && requires{
                    {begin_type{begin}} noexcept;
                    {++begin} noexcept;
                    {begin != end} noexcept;
                })
            ))
        {
            if (begin == end) {
                return None;
            }
            if constexpr (meta::has_ssize<Value>) {
                auto size = meta::ssize(this->value) - 1;
                begin += size;
                index += size + (size * !trivial);
            } else {
                begin_type it = begin;
                ++it;
                while (it != end) {
                    ++it;
                    ++begin;
                    index += 1 + !trivial;
                }
            }
            if (auto last = arg<join_reverse>(outer); last.begin != last.end) {
                return std::move(last);
            }
            if constexpr (!trivial) {
                --index;
                if (outer.sep_size[depth] != 0) {
                    return sep<join_reverse>(outer);
                }
            }
            --index;
            --begin;
            while (index >= 0) {
                if (auto next = arg<join_reverse>(outer); next.begin != next.end) {
                    return std::move(next);
                }
                index -= 1 + !trivial;
                --begin;
            }
            return None;
        }

        template <typename T>
        static constexpr T _deref(const unique& child)
            noexcept (requires{{impl::basic_vtable<join_deref<T>::template fn, unique_alternatives>{
                impl::visitable<const unique&>::index(child)
            }(child)} noexcept;})
        {
            return impl::basic_vtable<join_deref<T>::template fn, unique_alternatives>{
                impl::visitable<const unique&>::index(child)
            }(child);
        }

        static constexpr std::strong_ordering _compare(const unique& lhs, const unique& rhs)
            noexcept (requires{{impl::basic_vtable<join_compare, unique_alternatives>{
                impl::visitable<const unique&>::index(lhs)
            }(lhs, rhs)} noexcept;})
        {
            return impl::basic_vtable<join_compare, unique_alternatives>{
                impl::visitable<const unique&>::index(lhs)
            }(lhs, rhs);
        }

    public:
        [[nodiscard]] constexpr join_subrange(
            Outer& outer,
            meta::forward<Value> value,
            join_forward
        )
            noexcept (requires{
                {Value(std::forward<Value>(value))} noexcept;
                {join_begin<Dir>(this->value)} noexcept;
                {join_end<Dir>(this->value)} noexcept;
                {forward_init(outer)} noexcept;
            })
            requires (requires{
                {Value(std::forward<Value>(value))};
                {join_begin<Dir>(this->value)};
                {join_end<Dir>(this->value)};
                {forward_init(outer)};
            })
        :
            value(std::forward<Value>(value)),
            begin(join_begin<Dir>(this->value)),
            end(join_end<Dir>(this->value)),
            child(forward_init(outer))
        {}

        [[nodiscard]] constexpr join_subrange(
            Outer& outer,
            meta::forward<Value> value,
            join_reverse
        )
            noexcept (requires{
                {Value(std::forward<Value>(value))} noexcept;
                {join_begin<Dir>(this->value)} noexcept;
                {join_end<Dir>(this->value)} noexcept;
                {reverse_init(outer)} noexcept;
            })
            requires (requires{
                {Value(std::forward<Value>(value))};
                {join_begin<Dir>(this->value)};
                {join_end<Dir>(this->value)};
                {reverse_init(outer)};
            })
        :
            value(std::forward<Value>(value)),
            begin(join_begin<Dir>(this->value)),
            end(join_end<Dir>(this->value)),
            child(reverse_init(outer))
        {}

        template <typename T>
        [[nodiscard]] constexpr T deref() const
            noexcept (requires{{_deref<T>(*child)} noexcept;})
        {
            return _deref<T>(*child);
        }

        [[nodiscard]] constexpr bool increment(Outer& outer)
            noexcept (requires{{join_visit<join_increment>(*this, outer)} noexcept;})
        {
            return join_visit<join_increment>(*this, outer);
        }

        [[nodiscard]] constexpr bool increment(Outer& outer, ssize_t& n)
            noexcept (requires{{join_visit<join_increment>(*this, outer, n)} noexcept;})
        {
            return join_visit<join_increment>(*this, outer, n);
        }

        [[nodiscard]] constexpr bool decrement(Outer& outer)
            noexcept (requires{{join_visit<join_decrement>(*this, outer)} noexcept;})
        {
            return join_visit<join_decrement>(*this, outer);
        }

        [[nodiscard]] constexpr bool decrement(Outer& outer, ssize_t& n)
            noexcept (requires{{join_visit<join_decrement>(*this, outer, n)} noexcept;})
        {
            return join_visit<join_decrement>(*this, outer, n);
        }

        [[nodiscard]] constexpr ssize_t distance(Outer& outer, const join_subrange& other) const
            noexcept (requires{{join_visit<join_distance>(outer, *this, other)} noexcept;})
        {
            return join_visit<join_distance>(outer, *this, other);
        }

        [[nodiscard]] constexpr std::strong_ordering operator<=>(const join_subrange& other) const
            noexcept (requires{{_compare(*child, *other.child)} noexcept;})
        {
            if (std::strong_ordering cmp = index <=> other.index; cmp != 0) return cmp;
            return _compare(*child, *other.child);
        }
    };

    /* Join iterators simply store the control block as an optional, where an empty
    optional represents a common sentinel.  `None` may be used as an alternate sentinel
    as an optimization. */
    template <meta::not_reference Outer, join_direction Dir>
    struct join_iterator {
        static constexpr size_t depth = 0;
        static constexpr bool trivial = requires(Outer& outer) {
            {outer.seps.template get<0>()} -> meta::is<impl::scalar_range<impl::join_tag>>;
        };

        template <size_t I> requires (I < Outer::arg_type::size())
        using child_type = join_subrange<
            Outer,
            Dir,
            1,
            decltype((std::declval<Outer&>().args.template get<I>()))
        >;

    private:
        template <typename = std::make_index_sequence<Outer::arg_type::size()>>
        struct _unique;
        template <size_t... I>
        struct _unique<std::index_sequence<I...>> {
            using separator = void;
            using unique = meta::make_union<child_type<I>...>;
        };
        template <size_t... I> requires (!trivial && sizeof...(I) > 1)
        struct _unique<std::index_sequence<I...>> {
            using separator = join_subrange<
                Outer,
                Dir,
                Outer::sep_type::size(),
                decltype((std::declval<Outer&>().seps.template get<0>()))
            >;
            using unique = meta::make_union<separator, child_type<I>...>;
        };

    public:
        using separator = _unique<>::separator;
        using unique = _unique<>::unique;
        static constexpr size_t alternatives =
            Outer::arg_type::size() + (Outer::arg_type::size() - 1) * !trivial;
        static constexpr size_t unique_alternatives =
            impl::visitable<unique>::alternatives::size();

        template <size_t I> requires (I < alternatives)
        static constexpr size_t alternative = (!trivial && I % 2 == 1) ?
            0 :
            impl::visitable<const unique&>::alternatives::template index<
                const child_type<I / (1 + !trivial)>&
            >();

        using iterator_category = std::conditional_t<
            meta::inherits<join_category<unique>, std::forward_iterator_tag>,
            std::conditional_t<
                meta::inherits<join_category<unique>, std::random_access_iterator_tag>,
                std::random_access_iterator_tag,
                join_category<unique>
            >,
            std::forward_iterator_tag
        >;
        using difference_type = ssize_t;
        using reference = join_reference<unique>::template eval<meta::make_union>;
        using value_type = meta::remove_reference<reference>;
        using pointer = meta::as_pointer<value_type>;

        Outer* outer;
        ssize_t index;
        [[no_unique_address]] Optional<unique> child;

        template <join_direction D = join_forward> requires (!trivial)
        [[nodiscard]] constexpr auto sep(Outer& outer)
            noexcept (requires{{separator{outer, outer.seps.template get<depth>(), D{}}} noexcept;})
        {
            return separator{outer, outer.seps.template get<depth>(), D{}};
        }

        template <size_t I, join_direction D = join_forward> requires (I < Outer::arg_type::size())
        [[nodiscard]] constexpr auto arg(Outer& outer)
            noexcept (requires{{child_type<I>{outer, outer.args.template get<I>(), D{}}} noexcept;})
        {
            return child_type<I>{outer, outer.args.template get<I>(), D{}};
        }

    private:
        template <ssize_t I = 0> requires (I < Outer::arg_type::ssize())
        constexpr Optional<unique> init(Outer& outer)
            noexcept (requires(decltype(arg<I>(outer)) first) {
                {arg<I>(outer)} noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
                {first.begin != first.end} noexcept -> meta::nothrow::truthy;
            } && (I + 1 == Outer::arg_type::ssize() || (
                requires{{init<I + 1>(outer)} noexcept;} &&
                (trivial || I != 0 || requires{
                    {sep(outer)} noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
                })
            )))
            requires (std::same_as<Dir, join_forward>)
        {
            if (auto first = arg<I>(outer); first.begin != first.end) {
                return std::move(first);
            }
            if constexpr (I + 1 < Outer::arg_type::ssize()) {
                if constexpr (!trivial && I == 0) {
                    ++index;
                    if (outer.sep_size[0] != 0) {
                        return sep(outer);
                    }
                    ++index;
                } else {
                    index += 1 + !trivial;
                }
                return init<I + 1>(outer);
            } else {
                ++index;
                return None;
            }
        }

        template <ssize_t I = Outer::arg_type::ssize() - 1> requires (I >= 0)
        constexpr Optional<unique> init(Outer& outer)
            noexcept (requires(decltype(arg<I>(outer)) first) {
                {arg<I>(outer)} noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
                {first.begin != first.end} noexcept -> meta::nothrow::truthy;
            } && (I == 0 || (
                requires{{init<I - 1>(outer)} noexcept;} &&
                (trivial || I != Outer::arg_type::ssize() - 1 || requires{
                    {sep(outer)} noexcept -> meta::nothrow::convertible_to<Optional<unique>>;
                })
            )))
            requires (std::same_as<Dir, join_reverse>)
        {
            if (auto first = arg<I>(outer); first.begin != first.end) {
                return std::move(first);
            }
            if constexpr (I > 0) {
                if constexpr (!trivial && I == Outer::arg_type::ssize() - 1) {
                    ++index;
                    if (outer.sep_size[0] != 0) {
                        return sep(outer);
                    }
                    ++index;
                } else {
                    index += 1 + !trivial;
                }
                return init<I - 1>(outer);
            } else {
                ++index;
                return None;
            }
        }

        static constexpr decltype(auto) _deref(const unique& child)
            noexcept (requires{{
                impl::basic_vtable<join_deref<reference>::template fn, unique_alternatives>{
                    impl::visitable<const unique&>::index(child)
                }(child)
            } noexcept;})
        {
            return (impl::basic_vtable<join_deref<reference>::template fn, unique_alternatives>{
                impl::visitable<const unique&>::index(child)
            }(child));
        }

        static constexpr std::strong_ordering _compare(const unique& lhs, const unique& rhs)
            noexcept (requires{{impl::basic_vtable<join_compare, unique_alternatives>{
                impl::visitable<const unique&>::index(lhs)
            }(lhs, rhs)} noexcept;})
        {
            return impl::basic_vtable<join_compare, unique_alternatives>{
                impl::visitable<const unique&>::index(lhs)
            }(lhs, rhs);
        }

    public:
        [[nodiscard]] constexpr join_iterator(Outer* outer = nullptr) noexcept :
            outer(outer),
            index(alternatives)
        {}

        [[nodiscard]] constexpr join_iterator(Outer& outer)
            noexcept (requires{{init(outer)} noexcept;})
            requires (requires{{init(outer)};})
        :
            outer(&outer),
            index(0),
            child(init(outer))
        {}

        [[nodiscard]] constexpr decltype(auto) operator*() const
            noexcept (requires{{_deref(*child)} noexcept;})
        {
            return (_deref(*child));
        }

        [[nodiscard]] constexpr auto operator->() const
            noexcept (requires{{impl::arrow{*this}} noexcept;})
            requires (requires{{impl::arrow{*this}};})
        {
            return impl::arrow{*this};
        }

        // [[nodiscard]] constexpr reference operator[](difference_type n) const
        //     noexcept (requires(join_iterator tmp) {
        //         {join_iterator{*this}} noexcept;
        //         {tmp += n} noexcept;
        //         {*tmp} noexcept;
        //     })
        //     requires (requires(join_iterator tmp) {
        //         {join_iterator{*this}};
        //         {tmp += n};
        //         {*tmp};
        //     })
        // {
        //     join_iterator tmp {*this};
        //     tmp += n;
        //     return (*tmp);
        // }

        constexpr join_iterator& operator++()
            noexcept (requires{{join_visit<join_increment>(*this, *outer)} noexcept;})
            requires (requires{{join_visit<join_increment>(*this, *outer)};})
        {
            join_visit<join_increment>(*this, *outer);
            return *this;
        }

        [[nodiscard]] constexpr join_iterator operator++(int)
            noexcept (requires{
                {join_iterator{*this}} noexcept;
                {++*this} noexcept;
            })
            requires (requires{
                {join_iterator{*this}};
                {++*this};
            })
        {
            join_iterator tmp {*this};
            ++*this;
            return tmp;
        }

        // constexpr join_iterator& operator+=(difference_type n)
        //     noexcept (requires{
        //         {join_visit<join_increment>(*this, *outer, n)} noexcept;
        //     })
        //     requires (requires{{join_visit<join_increment>(*this, *outer, n)};})
        // {
        //     join_visit<join_increment>(*this, *outer, n);
        //     return *this;
        // }

        // [[nodiscard]] friend constexpr join_iterator operator+(
        //     const join_iterator& self,
        //     difference_type n
        // )
        //     noexcept (requires(join_iterator tmp) {
        //         {join_iterator{self}} noexcept;
        //         {tmp += n} noexcept;
        //     })
        //     requires (requires(join_iterator tmp) {
        //         {join_iterator{self}};
        //         {tmp += n};
        //     })
        // {
        //     join_iterator tmp {self};
        //     tmp += n;
        //     return tmp;
        // }

        // [[nodiscard]] friend constexpr join_iterator operator+(
        //     difference_type n,
        //     const join_iterator& self
        // )
        //     noexcept (requires(join_iterator tmp) {
        //         {join_iterator{self}} noexcept;
        //         {tmp += n} noexcept;
        //     })
        //     requires (requires(join_iterator tmp) {
        //         {join_iterator{self}};
        //         {tmp += n};
        //     })
        // {
        //     join_iterator tmp {self};
        //     tmp += n;
        //     return tmp;
        // }

        // constexpr join_iterator& operator--()
        //     noexcept (requires{{join_visit<join_decrement>(*this, *outer)} noexcept;})
        //     requires (requires{{join_visit<join_decrement>(*this, *outer)};})
        // {
        //     /// TODO: what about decrementing an end iterator, where `curr` is none?
        //     /// This should probably just initialize to the last valid position.
        //     join_visit<join_decrement>(*this, *outer);
        //     return *this;
        // }

        // [[nodiscard]] constexpr join_iterator operator--(int)
        //     noexcept (requires{
        //         {join_iterator{*this}} noexcept;
        //         {--*this} noexcept;
        //     })
        //     requires (requires{
        //         {join_iterator{*this}};
        //         {--*this};
        //     })
        // {
        //     join_iterator temp {*this};
        //     --*this;
        //     return temp;
        // }

        // constexpr join_iterator& operator-=(difference_type n)
        //     noexcept (requires{
        //         {join_visit<join_decrement>(*this, *outer, n)} noexcept;
        //     })
        //     requires (requires{{join_visit<join_decrement>(*this, *outer, n)};})
        // {
        //     join_visit<join_decrement>(*this, *outer, n);
        //     return *this;
        // }

        // [[nodiscard]] constexpr join_iterator operator-(difference_type n) const
        //     noexcept (requires(join_iterator tmp) {
        //         {join_iterator{*this}} noexcept;
        //         {tmp -= n} noexcept;
        //     })
        //     requires (requires(join_iterator tmp) {
        //         {join_iterator{*this}};
        //         {tmp -= n};
        //     })
        // {
        //     join_iterator tmp {*this};
        //     tmp -= n;
        //     return tmp;
        // }

        // [[nodiscard]] constexpr difference_type operator-(const join_iterator& other) const
        //     noexcept (requires{
        //         {join_visit<join_distance>(*this, other, *outer)} noexcept;
        //     })
        //     requires (requires{{join_visit<join_distance>(*this, other, *outer)};})
        // {
        //     return join_visit<join_distance>(*this, other, *outer);
        // }

        [[nodiscard]] constexpr bool operator==(const join_iterator& other) const
            noexcept (requires{{*this <=> other} noexcept;})
        {
            return (*this <=> other) == std::strong_ordering::equal;
        }

        [[nodiscard]] constexpr std::strong_ordering operator<=>(const join_iterator& other) const
            noexcept (requires{{_compare(*child, *other.child)} noexcept;})
        {
            if (std::strong_ordering cmp = index <=> other.index; cmp != 0) return cmp;
            if (index < 0 || index >= ssize_t(alternatives)) return std::strong_ordering::equal;
            return _compare(*child, *other.child);
        }
    };

    template <typename... T>
    using join_tuple = impl::basic_tuple<join_wrap<T>...>;

    /* The public join container stores a tuple for the separators and a tuple for the
    arguments, and serves as an entry point for `join_iterator`. */
    template <typename, meta::not_rvalue... A> requires (sizeof...(A) > 0)
    struct join;
    template <meta::unqualified Sep, meta::unqualified... Seps, meta::not_rvalue... A>
        requires (sizeof...(A) > 0)
    struct join<meta::pack<Sep, Seps...>, A...> {
        using sep_type = join_tuple<Sep, Seps...>;
        using arg_type = join_tuple<A...>;
        using sep_size_type = std::array<ssize_t, sizeof...(Seps) + 1>;

        [[no_unique_address]] sep_type seps;
        [[no_unique_address]] arg_type args;
        [[no_unique_address]] sep_size_type sep_size;

    private:
        template <typename T>
        static constexpr ssize_t get_sep_size(T& sep)
            noexcept (!meta::range<T> || requires{{ssize_t(meta::distance(sep))} noexcept;})
            requires (!meta::range<T> || requires{{ssize_t(meta::distance(sep))};})
        {
            if constexpr (meta::range<T>) {
                return ssize_t(meta::distance(sep));
            } else {
                return 1;
            }
        }

        template <size_t... I>
        constexpr sep_size_type get_sep_sizes(std::index_sequence<I...>)
            noexcept (requires{
                {sep_size_type{get_sep_size(seps.template get<I>())...}} noexcept;
            })
            requires (requires{{sep_size_type{get_sep_size(seps.template get<I>())...}};})
        {
            return {get_sep_size(seps.template get<I>())...};
        }

    public:
        [[nodiscard]] constexpr join(const join_tuple<Sep, Seps...>& seps, meta::forward<A>... args)
            noexcept (requires{
                {sep_type(seps)} noexcept;
                {arg_type(std::forward<A>(args)...)} noexcept;
                {get_sep_sizes(std::index_sequence_for<Sep, Seps...>{})} noexcept;
            })
            requires (requires{
                {sep_type(seps)};
                {arg_type(std::forward<A>(args)...)};
                {get_sep_sizes(std::index_sequence_for<Sep, Seps...>{})};
            })
        :
            seps(seps),
            args(std::forward<A>(args)...),
            sep_size(get_sep_sizes(std::index_sequence_for<Sep, Seps...>{}))
        {}
        [[nodiscard]] constexpr join(join_tuple<Sep, Seps...>&& seps, meta::forward<A>... args)
            noexcept (requires{
                {sep_type(std::move(seps))} noexcept;
                {arg_type(std::forward<A>(args)...)} noexcept;
                {get_sep_sizes(std::index_sequence_for<Sep, Seps...>{})} noexcept;
            })
            requires (requires{
                {sep_type(std::move(seps))};
                {arg_type(std::forward<A>(args)...)};
                {get_sep_sizes(std::index_sequence_for<Sep, Seps...>{})};
            })
        :
            seps(std::move(seps)),
            args(std::forward<A>(args)...),
            sep_size(get_sep_sizes(std::index_sequence_for<Sep, Seps...>{}))
        {}

        [[nodiscard]] constexpr join_iterator<join, join_forward> begin()
            noexcept (requires{{join_iterator<join, join_forward>{*this}} noexcept;})
            requires (requires{{join_iterator<join, join_forward>{*this}};})
        {
            return {*this};
        }

        [[nodiscard]] constexpr join_iterator<const join, join_forward> begin() const
            noexcept (requires{{join_iterator<const join, join_forward>{*this}} noexcept;})
            requires (requires{{join_iterator<const join, join_forward>{*this}};})
        {
            return {*this};
        }

        [[nodiscard]] constexpr join_iterator<join, join_forward> end() noexcept {
            return {this};
        }

        [[nodiscard]] constexpr join_iterator<const join, join_forward> end() const noexcept {
            return {this};
        }

        [[nodiscard]] constexpr join_iterator<join, join_reverse> rbegin()
            noexcept (requires{{join_iterator<join, join_reverse>{*this}} noexcept;})
            requires (requires{{join_iterator<join, join_reverse>{*this}};})
        {
            return {*this};
        }

        [[nodiscard]] constexpr join_iterator<const join, join_reverse> rbegin() const
            noexcept (requires{{join_iterator<const join, join_reverse>{*this}} noexcept;})
            requires (requires{{join_iterator<const join, join_reverse>{*this}};})
        {
            return {*this};
        }

        [[nodiscard]] constexpr join_iterator<join, join_reverse> rend() noexcept {
            return {this};
        }

        [[nodiscard]] constexpr join_iterator<const join, join_reverse> rend() const noexcept {
            return {this};
        }
    };

}


namespace iter {

    template <meta::not_void Sep> requires (meta::not_rvalue<Sep>)
    struct concat {
        [[no_unique_address]] impl::join_tuple<Sep> sep;

        [[nodiscard]] constexpr concat() = default;
        [[nodiscard]] constexpr concat(meta::forward<Sep> sep)
            noexcept (requires{{Sep(std::forward<Sep>(sep))} noexcept;})
            requires (requires{{Sep(std::forward<Sep>(sep))};})
        :
            sep(std::forward<Sep>(sep))
        {}

        [[nodiscard]] static constexpr range<> operator()() noexcept {
            return {};
        }

        template <typename Self, typename... A> requires (sizeof...(A) > 0)
        [[nodiscard]] constexpr auto operator()(this Self&& self, A&&... a)
            noexcept (requires{{range<impl::join<
                meta::pack<Sep>,
                meta::remove_rvalue<A>...
            >>{std::forward<Self>(self).sep, std::forward<A>(a)...}} noexcept;})
            requires (requires{{range<impl::join<
                meta::pack<Sep>,
                meta::remove_rvalue<A>...
            >>{std::forward<Self>(self).sep, std::forward<A>(a)...}};})
        {
            return range<impl::join<
                meta::pack<Sep>,
                meta::remove_rvalue<A>...
            >>{std::forward<Self>(self).sep, std::forward<A>(a)...};
        }
    };

    template <typename T = impl::join_tag>
    concat(T&& = {}) -> concat<meta::remove_rvalue<T>>;

    template <meta::not_void... Sep> requires ((sizeof...(Sep) > 0) && ... && meta::not_rvalue<Sep>)
    struct join {
        [[no_unique_address]] impl::join_tuple<impl::join_tag, Sep...> sep;

        [[nodiscard]] constexpr join() = default;
        [[nodiscard]] constexpr join(meta::forward<Sep>... sep)
            noexcept (requires{{impl::join_tuple<Sep...>{std::forward<Sep>(sep)...}} noexcept;})
            requires (
                sizeof...(Sep) > 0 &&
                requires{{impl::join_tuple<impl::join_tag, Sep...>{{}, std::forward<Sep>(sep)...}};}
            )
        :
            sep{{}, std::forward<Sep>(sep)...}
        {}

        template <typename Self, typename A>
        [[nodiscard]] constexpr auto operator()(this Self&& self, A&& a)
            noexcept (requires{{range<impl::join<
                meta::pack<impl::join_tag, Sep...>,
                meta::remove_rvalue<A>
            >>{std::forward<Self>(self).sep, std::forward<A>(a)}} noexcept;})
            requires (requires{{range<impl::join<
                meta::pack<impl::join_tag, Sep...>,
                meta::remove_rvalue<A>
            >>{std::forward<Self>(self).sep, std::forward<A>(a)}};})
        {
            return range<impl::join<
                meta::pack<impl::join_tag, Sep...>,
                meta::remove_rvalue<A>
            >>{std::forward<Self>(self).sep, std::forward<A>(a)};
        }
    };

    /// NOTE: current C++ does not allow for default types for parameter packs,
    /// so we have to manually unroll the `join{}` constructor in order to allow for
    /// anonymous closures (e.g. `iter::join{sep1, {}, sep3}`).

    template <typename T1 = impl::join_tag>
    join(T1&& = {}) -> join<meta::remove_rvalue<T1>>;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag
    >
    join(T1&&, T2&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>
    >;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag,
        typename T3 = impl::join_tag
    >
    join(T1&&, T2&&, T3&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>,
        meta::remove_rvalue<T3>
    >;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag,
        typename T3 = impl::join_tag,
        typename T4 = impl::join_tag
    >
    join(T1&&, T2&&, T3&&, T4&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>,
        meta::remove_rvalue<T3>,
        meta::remove_rvalue<T4>
    >;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag,
        typename T3 = impl::join_tag,
        typename T4 = impl::join_tag,
        typename T5 = impl::join_tag
    >
    join(T1&&, T2&&, T3&&, T4&&, T5&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>,
        meta::remove_rvalue<T3>,
        meta::remove_rvalue<T4>,
        meta::remove_rvalue<T5>
    >;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag,
        typename T3 = impl::join_tag,
        typename T4 = impl::join_tag,
        typename T5 = impl::join_tag,
        typename T6 = impl::join_tag
    >
    join(T1&&, T2&&, T3&&, T4&&, T5&&, T6&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>,
        meta::remove_rvalue<T3>,
        meta::remove_rvalue<T4>,
        meta::remove_rvalue<T5>,
        meta::remove_rvalue<T6>
    >;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag,
        typename T3 = impl::join_tag,
        typename T4 = impl::join_tag,
        typename T5 = impl::join_tag,
        typename T6 = impl::join_tag,
        typename T7 = impl::join_tag
    >
    join(T1&&, T2&&, T3&&, T4&&, T5&&, T6&&, T7&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>,
        meta::remove_rvalue<T3>,
        meta::remove_rvalue<T4>,
        meta::remove_rvalue<T5>,
        meta::remove_rvalue<T6>,
        meta::remove_rvalue<T7>
    >;
    template <
        typename T1 = impl::join_tag,
        typename T2 = impl::join_tag,
        typename T3 = impl::join_tag,
        typename T4 = impl::join_tag,
        typename T5 = impl::join_tag,
        typename T6 = impl::join_tag,
        typename T7 = impl::join_tag,
        typename T8 = impl::join_tag
    >
    join(T1&&, T2&&, T3&&, T4&&, T5&&, T6&&, T7&&, T8&&) -> join<
        meta::remove_rvalue<T1>,
        meta::remove_rvalue<T2>,
        meta::remove_rvalue<T3>,
        meta::remove_rvalue<T4>,
        meta::remove_rvalue<T5>,
        meta::remove_rvalue<T6>,
        meta::remove_rvalue<T7>,
        meta::remove_rvalue<T8>
    >;
    

    static constexpr auto j = join{}(concat{}(1, 2, 3));
    static_assert([] {
        for (auto&& x : j) {
            // if (x != 1 && x != 2 && x != 3) return false;
        }
        return true;
    }());

}


namespace impl {

    template <typename T>
    concept join_flatten = meta::range<T> && meta::range<meta::yield_type<T>>;

    enum class join_direction : uint8_t {
        FORWARD,
        REVERSE
    };

    template <typename T>
    constexpr bool _is_join_subrange = false;
    template <typename T>
    concept is_join_subrange = _is_join_subrange<meta::unqualify<T>>;
    template <typename T>
    concept is_join_nested = is_join_subrange<T> && join_flatten<
        meta::dereference_type<typename meta::unqualify<T>::begin_type>
    >;

    template <typename Sep, typename... Subranges>
    concept join_union_concept = sizeof...(Subranges) > 0 &&
        (meta::is_void<Sep> || (meta::unqualified<Sep> && is_join_subrange<Sep>)) &&
        ((meta::unqualified<Subranges> && is_join_subrange<Subranges>) && ...) &&
        (meta::is_void<Sep> || (Sep::direction == meta::unpack_type<0, Subranges...>::direction)) &&
        ((meta::unpack_type<0, Subranges...>::direction == Subranges::direction) && ...);

    template <typename Sep, typename... Subranges>
        requires (join_union_concept<Sep, Subranges...>)
    struct _join_union {
        using type = meta::make_union<Subranges...>;
        static constexpr bool trivial = meta::trivial_union<Subranges...>;
    };
    template <meta::not_void Sep, typename... Subranges>
        requires (join_union_concept<Sep, Subranges...>)
    struct _join_union<Sep, Subranges...> {
        using type = meta::make_union<Sep, Subranges...>;
        static constexpr bool trivial = meta::trivial_union<Sep, Subranges...>;
    };

    /* Join iterators and nested subranges store the active subrange in an internal
    union that filters out duplicates based on the begin and end types for each
    argument and separator.  If all share the same iterator types, then the union will
    be optimized away entirely, eliminating dispatch overhead.  If only some arguments
    share iterators, then the union size will be minimized on that basis, which
    increases the likelihood of dispatch optimizations.  The only downside is that the
    union's index no longer reflects the active argument being joined, which
    necessitates a separate tracking index. */
    template <typename Sep, typename... Subranges> requires (join_union_concept<Sep, Subranges...>)
    struct join_union {
        using type = _join_union<Sep, Subranges...>::type;
        static constexpr bool trivial = _join_union<Sep, Subranges...>::trivial;

        static constexpr size_t size() noexcept {
            return trivial ? 1 : visitable<type>::alternatives::size();
        }

        static constexpr ssize_t ssize() noexcept {
            return ssize_t(size());
        }

        [[no_unique_address]] Optional<type> data;

        /* Get the active index of the storage union.  Note that this does not
        necessarily correspond to the active argument in the joined range, due to
        duplicate subranges being filtered out.  Additionally, if a separator is
        present, then it will always be stored at index 0, followed by the unique
        subranges.  This index will be used to specialize any function template
        provided to `visit<F>()`. */
        constexpr size_t active() const noexcept {
            if constexpr (trivial) {
                return 0;
            } else {
                return data.__value.template get<1>().__value.index();
            }
        }

        /* Visit the inner union with a vtable function that accepts the `active()`
        index as a template parameter.  The function will then be called with the
        given arguments, and `get<I>()` can be used to safely access the inner
        subrange(s). */
        template <template <size_t> class F, typename... A>
        constexpr decltype(auto) visit(A&&... args) const
            noexcept (requires{
                {impl::basic_vtable<F, size()>{active()}(std::forward<A>(args)...)} noexcept;
            })
            requires (requires{
                {impl::basic_vtable<F, size()>{active()}(std::forward<A>(args)...)};
            })
        {
            return (impl::basic_vtable<F, size()>{active()})(std::forward<A>(args)...);
        }

        /* Access the current subrange as the indicated type, where `I` matches the
        semantics for `active()` and `visit()`. */
        template <size_t I, typename Self> requires (I < size())
        [[nodiscard]] constexpr decltype(auto) get(this Self&& self) noexcept {
            if constexpr (trivial) {
                return (std::forward<Self>(self).data.__value.template get<1>());
            } else {
                return (std::forward<Self>(self).data.
                    __value.template get<1>().
                    __value.template get<I>()
                );
            }
        }
    };

    template <typename Sep, typename Begin, typename End>
    concept join_subrange_concept =
        (meta::is_void<Sep> || (meta::unqualified<Sep> && is_join_subrange<Sep>)) &&
        meta::unqualified<Begin> &&
        meta::unqualified<End> &&
        meta::iterator<Begin> &&
        meta::sentinel_for<End, Begin>;

    /* Join iterators have to store both the begin and end iterators for every argument
    and separator, so that they can smoothly transition from one to the next.  This
    class encapsulates those iterators for any non-range or non-nested value, and is
    used to specialize `join_union` for the outer iterator or nested subrange. */
    template <join_direction D, typename Sep, typename Begin, typename End>
        requires (join_subrange_concept<Sep, Begin, End>)
    struct join_subrange {
        using begin_type = Begin;
        using end_type = End;
        static constexpr join_direction direction = D;
        begin_type begin;
        end_type end;
        ssize_t index = 0;
    };

    template <join_direction D, typename Sep, typename Begin, typename End>
    constexpr bool _is_join_subrange<join_subrange<D, Sep, Begin, End>> = true;

    /* `join_forward` produces a `join_subrange` containing forward iterators over an
    arbitrary argument.  If the argument is not a range, then this will yield a trivial
    subrange over a single element.  Otherwise, if the argument is a range, then it
    will reuse the same iterators as the range itself.  If that range yields further
    ranges, then `join_forward` will advance the resulting subrange to the first
    non-empty element or separator before returning. */
    template <typename A>
    struct join_forward;
    template <typename A> requires (!meta::range<A>)
    struct join_forward<A> {
        using type = A;

        template <typename Sep>
        using subrange = join_subrange<
            join_direction::FORWARD,
            Sep,
            impl::contiguous_iterator<A>,
            impl::contiguous_iterator<A>
        >;

        A arg;

        template <typename Sep>
        constexpr auto begin()
            noexcept (requires{{subrange<Sep>{
                .begin = {std::addressof(arg)},
                .end = {std::addressof(arg) + 1}
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = {std::addressof(arg)},
                .end = {std::addressof(arg) + 1}
            }};})
        {
            return subrange<Sep>{
                .begin = {std::addressof(arg)},
                .end = {std::addressof(arg) + 1}
            };
        }

        template <typename Sep>
        constexpr auto end()
            noexcept (requires{{subrange<Sep>{
                .begin = {std::addressof(arg) + 1},
                .m_end = {std::addressof(arg) + 1}
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = {std::addressof(arg) + 1},
                .end = {std::addressof(arg) + 1}
            }};})
        {
            return subrange<Sep>{
                .begin = {std::addressof(arg) + 1},
                .end = {std::addressof(arg) + 1}
            };
        }
    };
    template <meta::range A>
    struct join_forward<A> {
        using type = join_forward<meta::yield_type<A>>::type;

        template <typename Sep>
        using subrange = join_subrange<
            join_direction::FORWARD,
            Sep,
            meta::unqualify<meta::begin_type<A>>,
            meta::unqualify<meta::end_type<A>>
        >;

        A arg;

        template <typename Sep>
        constexpr auto begin()
            noexcept (requires{{subrange<Sep>{
                .begin = arg.begin(),
                .end = arg.end()
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = arg.begin(),
                .end = arg.end()
            }};})
        {
            return subrange<Sep>{
                .begin = arg.begin(),
                .end = arg.end()
            };
        }

        template <typename Sep>
        constexpr auto end()
            noexcept (requires{{subrange<Sep>{
                .begin = arg.end(),
                .end = arg.end()
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = arg.end(),
                .end = arg.end()
            }};})
        {
            return subrange<Sep>{
                .begin = arg.end(),
                .end = arg.end()
            };
        }
    };
    template <typename A>
    join_forward(A&) -> join_forward<A&>;

    /* `join_reverse` works identically to `join_forward`, except that the subranges
    encapsulate reverse iterators rather than forward ones. */
    template <typename A>
    struct join_reverse;
    template <typename A> requires (!meta::range<A>)
    struct join_reverse<A> {
        using type = A;

        template <typename Sep>
        using subrange = join_subrange<
            join_direction::REVERSE,
            Sep,
            std::reverse_iterator<impl::contiguous_iterator<A>>,
            std::reverse_iterator<impl::contiguous_iterator<A>>
        >;

        A arg;

        template <typename Sep>
        constexpr auto begin()
            noexcept (requires{{subrange<Sep>{
                .begin = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg) + 1}
                ),
                .end = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                )
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg) + 1}
                ),
                .end = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                )
            }};})
        {
            return subrange<Sep>{
                .begin = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg) + 1}
                ),
                .end = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                )
            };
        }

        template <typename Sep>
        constexpr auto end()
            noexcept (requires{{subrange<Sep>{
                .begin = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                ),
                .end = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                )
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                ),
                .end = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                )
            }};})
        {
            return subrange<Sep>{
                .begin = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                ),
                .end = std::make_reverse_iterator(
                    impl::contiguous_iterator<A>{std::addressof(arg)}
                )
            };
        }
    };
    template <meta::range A>
        requires (meta::reverse_iterable<A> && (
            !meta::range<meta::reverse_yield_type<A>> ||
            meta::reverse_iterable<meta::reverse_yield_type<A>>
        ))
    struct join_reverse<A> {
        using type = join_reverse<meta::reverse_yield_type<A>>::type;

        template <typename Sep>
        using subrange = join_subrange<
            join_direction::REVERSE,
            Sep,
            meta::unqualify<meta::rbegin_type<A>>,
            meta::unqualify<meta::rend_type<A>>
        >;

        A arg;

        template <typename Sep>
        constexpr auto begin()
            noexcept (requires{{subrange<Sep>{
                .begin = arg.rbegin(),
                .end = arg.rend()
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = arg.rbegin(),
                .end = arg.rend()
            }};})
        {
            return subrange<Sep>{
                .begin = arg.rbegin(),
                .end = arg.rend()
            };
        }

        template <typename Sep>
        constexpr auto end()
            noexcept (requires{{subrange<Sep>{
                .begin = arg.rend(),
                .end = arg.rend()
            }} noexcept;})
            requires (requires{{subrange<Sep>{
                .begin = arg.rend(),
                .end = arg.rend()
            }};})
        {
            return subrange<Sep>{
                .begin = arg.rend(),
                .end = arg.rend()
            };
        }
    };
    template <typename C>
    join_reverse(C&) -> join_reverse<C&>;

    template <join_direction D, typename Sep, typename Begin, typename End>
    struct _join_subrange {
        using type = join_subrange<
            join_direction::FORWARD,
            Sep,
            meta::unqualify<meta::begin_type<meta::dereference_type<Begin>>>,
            meta::unqualify<meta::end_type<meta::dereference_type<Begin>>>
        >;
    };
    template <meta::is_void Sep, typename Begin, typename End>
    struct _join_subrange<join_direction::REVERSE, Sep, Begin, End> {
        using type = join_subrange<
            join_direction::REVERSE,
            Sep,
            meta::unqualify<meta::rbegin_type<meta::dereference_type<Begin>>>,
            meta::unqualify<meta::rend_type<meta::dereference_type<Begin>>>
        >;
    };

    /* If a range of ranges is supplied as an argument or separator, then each of its
    recursive elements will be flattened into the output.  Such a subrange will consist
    of an outer iterator over the value at the current depth, as well as an inner
    iterator over its yield type, which will be cached within the subrange as long as
    it is needed.  The inner iterator is stored as another `join_subrange`, enabling
    recursion.  Additionally, if a separator is also present, then it will be inserted
    between each element of the outer iterator. */
    template <join_direction D, typename Sep, typename Begin, typename End>
        requires (
            join_subrange_concept<Sep, Begin, End> &&
            meta::range<meta::dereference_type<Begin>>
        )
    struct join_subrange<D, Sep, Begin, End> {
        using begin_type = Begin;
        using end_type = End;
        static constexpr join_direction direction = D;
        begin_type begin;
        end_type end;
        ssize_t index = 0;

        using separator_type = Sep;
        using storage_type =
            join_union<Sep, typename _join_subrange<direction, Sep, Begin, End>::type>;
        static constexpr bool has_sep = meta::not_void<Sep>;
        static constexpr size_t total_groups = 1 + has_sep;
        template <size_t G> requires (G < total_groups)
        static constexpr bool is_separator = G == 1;
        template <size_t G> requires (G < total_groups)
        static constexpr size_t normalize = G;

        [[no_unique_address]] Optional<meta::dereference_type<Begin>> data;
        [[no_unique_address]] storage_type subrange;

        /* Visit the subrange union with a vtable function that accepts
        `index % total_groups` as a template parameter.  This will always be either
        0 or 1, where 0 indicates a yielded subrange and 1 indicates a separator, if
        one is present.  The function will then be called with the outer subrange, and
        `get<G>()` can be used to safely access the nested type. */
        template <template <size_t> class F, typename... A>
        constexpr decltype(auto) visit(A&&... args) const
            noexcept (requires{{subrange.template visit<F>(std::forward<A>(args)...)} noexcept;})
            requires (requires{{subrange.template visit<F>(std::forward<A>(args)...)};})
        {
            return (subrange.template visit<F>(std::forward<A>(args)...));
        }

        /* Access the current subrange as the indicated type, where `G` is an index
        with the same semantics as `visit()`. */
        template <size_t G, typename Self> requires (G < total_groups)
        [[nodiscard]] constexpr decltype(auto) get(this Self&& self) noexcept {
            return std::forward<Self>(self).subrange.template get<G>();
        }

        /* Populate the `subrange` union with the group at index `G`.  The group can
        then be safely accessed via `get<G>()`. */
        template <size_t G, typename Iter> requires (!is_separator<G>)
        constexpr void init(const Iter& it)
            noexcept (requires{{data = *begin} noexcept;} && ((
                direction == join_direction::FORWARD && requires{
                    {subrange.data = join_forward{
                        data.__value.template get<1>()
                    }.template begin<Sep>()} noexcept;
                }
            ) || (
                direction == join_direction::REVERSE && requires{
                    {subrange.data = join_reverse{
                        data.__value.template get<1>()
                    }.template begin<Sep>()} noexcept;
                }
            )))
            requires (requires{{data = *begin};} && ((
                direction == join_direction::FORWARD && requires{
                    {subrange.data = join_forward{
                        data.__value.template get<1>()
                    }.template begin<Sep>()} noexcept;
                }
            ) || (
                direction == join_direction::REVERSE && requires{
                    {subrange.data = join_reverse{
                        data.__value.template get<1>()
                    }.template begin<Sep>()} noexcept;
                }
            )))
        {
            data = *begin;
            if constexpr (direction == join_direction::FORWARD) {
                subrange.data = join_forward{data.__value.template get<1>()}.template begin<Sep>();
            } else {
                subrange.data = join_reverse{data.__value.template get<1>()}.template begin<Sep>();
            }
        }

        /* Populate the `subrange` union with the group at index `G`.  The group can
        then be safely accessed via `get<G>()`. */
        template <size_t G, typename Iter> requires (is_separator<G>)
        constexpr void init(const Iter& it)
            noexcept ((direction == join_direction::FORWARD && requires{
                {subrange.data = join_forward{it.range->sep()}.template begin<Sep>()} noexcept;
            }) || (direction == join_direction::REVERSE && requires{
                {subrange.data = join_reverse{it.range->sep()}.template begin<Sep>()} noexcept;
            }))
            requires ((direction == join_direction::FORWARD && requires{
                {subrange.data = join_forward{it.range->sep()}.template begin<Sep>()};
            }) || (direction == join_direction::REVERSE && requires{
                {subrange.data = join_reverse{it.range->sep()}.template begin<Sep>()};
            }))
        {
            if constexpr (direction == join_direction::FORWARD) {
                subrange.data = join_forward{it.range->sep()}.template begin<Sep>();
            } else {
                subrange.data = join_reverse{it.range->sep()}.template begin<Sep>();
            }
        }
    };

    /* The yield type for the overall `join` range may need to be a union if any of the
    subrange yield types differ.  If a separator is provided, then its yield type must
    also be included in the union.  If all of the yield types are the same, then the
    union will collapse into a single type, and the `trivial` flag will be set to
    true. */
    template <typename R, join_direction D, typename>
    struct _join_yield_type;
    template <typename R, size_t... Is>
        requires (meta::is_void<typename meta::unqualify<R>::separator_type>)
    struct _join_yield_type<R, join_direction::FORWARD, std::index_sequence<Is...>> {
        using type = meta::make_union<
            typename join_forward<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
        static constexpr bool trivial = meta::trivial_union<
            typename join_forward<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
    };
    template <typename R, size_t... Is>
        requires (meta::not_void<typename meta::unqualify<R>::separator_type>)
    struct _join_yield_type<R, join_direction::FORWARD, std::index_sequence<Is...>> {
        using type = meta::make_union<
            typename join_forward<decltype((std::declval<R>().sep()))>::type,
            typename join_forward<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
        static constexpr bool trivial = meta::trivial_union<
            typename join_forward<decltype((std::declval<R>().sep()))>::type,
            typename join_forward<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
    };
    template <typename R, size_t... Is>
        requires (meta::is_void<typename meta::unqualify<R>::separator_type>)
    struct _join_yield_type<R, join_direction::REVERSE, std::index_sequence<Is...>> {
        using type = meta::make_union<
            typename join_reverse<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
        static constexpr bool trivial = meta::trivial_union<
            typename join_reverse<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
    };
    template <typename R, size_t... Is>
        requires (meta::not_void<typename meta::unqualify<R>::separator_type>)
    struct _join_yield_type<R, join_direction::REVERSE, std::index_sequence<Is...>> {
        using type = meta::make_union<
            typename join_reverse<decltype((std::declval<R>().sep()))>::type,
            typename join_reverse<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
        static constexpr bool trivial = meta::trivial_union<
            typename join_reverse<decltype((std::declval<R>().sep()))>::type,
            typename join_reverse<decltype((std::declval<R>().template arg<Is>()))>::type...
        >;
    };
    template <typename R, join_direction D>
    using join_yield_type = _join_yield_type<R, D, typename meta::unqualify<R>::indices>;

    template <typename R, typename Sep, typename... Subranges>
    concept join_iterator_concept =
        meta::lvalue<R> &&
        join_union_concept<Sep, Subranges...>;

    /* A simple tag that indicates to an iterator algorithm that a given group is
    currently uninitialized, and must be populated before the algorithm can
    continue. */
    struct join_fresh {};

    /* A simple enum that indicates the result of an increment or decrement operation,
    which bounds the recursion such that I never need to repeat comparisons. */
    enum class join_signal : uint8_t {
        GOOD,
        CONTINUE,
        BREAK
    };

    /* Join iterators work by storing a pointer to the joined range, an index recording
    the current sub-range, and a union of backing iterators, which store both the begin
    and end iterators for each range.  Scalars are promoted to ranges of length 1 for
    the purposes of this union.  When the iterator is incremented, the current begin
    iterator will be advanced, and if it equals the corresponding end iterator, the
    index will be incremented and the next range will be initialized, skipping any that
    are empty.  The same type will be used for both the begin and end iterators of the
    joined range so that it always models `common_range`.  End iterators in this case
    are simply represented as having an empty internal union and a group index equal to
    the number of arguments + number of separators in the outer range.

    Note that if a common type exists between all of the iterators, then the internal
    union will be optimized out, and the common iterator type will be stored directly,
    which avoids extra dispatching overhead.  Additionally, if all of the component
    ranges return a single type, then the overall joined iterator will dereference to
    that type directly.  Otherwise, it will return a union of the possible types across
    all of the ranges. */
    template <typename R, typename Sep, typename... Subranges>
        requires (join_iterator_concept<R, Sep, Subranges...>)
    struct join_iterator {
    private:
        using separator_type = Sep;
        using storage_type = join_union<Sep, Subranges...>;
        static constexpr join_direction direction = meta::unpack_type<0, Subranges...>::direction;
        using yield_type = join_yield_type<R, direction>::type;
        static constexpr bool has_sep = meta::not_void<Sep>;
        static constexpr size_t total_groups =
            sizeof...(Subranges) + (sizeof...(Subranges) - 1) * has_sep;
        template <size_t G> requires (G < total_groups)
        static constexpr bool is_separator = has_sep && (G % 2 == 1);
        template <size_t G> requires (G < total_groups)
        static constexpr size_t normalize = has_sep ? G / 2 : G;

    public:
        using iterator_category =
            join_traits<typename meta::unqualify<R>::ranges, Subranges...>::category;
        using difference_type =
            join_traits<typename meta::unqualify<R>::ranges, Subranges...>::difference;
        using value_type = meta::remove_reference<yield_type>;
        using reference = meta::as_lvalue<value_type>;
        using pointer = meta::address_type<value_type>;

    private:
        static constexpr bool bidirectional = meta::inherits<
            iterator_category,
            std::bidirectional_iterator_tag
        >;

        meta::as_pointer<R> range = nullptr;
        ssize_t index = total_groups;
        storage_type subrange;

        /* Visit the subrange union with a vtable function that accepts the current
        `index` as a template parameter.  The function will then be called with the
        iterator object, and `get<G>()` can be used to safely access the subrange. */
        template <template <size_t> class F, typename Self>
        constexpr decltype(auto) visit(this Self&& self)
            noexcept (requires{{impl::basic_vtable<F, total_groups>{size_t(self.index)}(
                std::forward<Self>(self)
            )} noexcept;})
            requires (requires{{impl::basic_vtable<F, total_groups>{size_t(self.index)}(
                std::forward<Self>(self)
            )};})
        {
            return (impl::basic_vtable<F, total_groups>{size_t(self.index)}(
                std::forward<Self>(self)
            ));
        }

        /* Access the current subrange as the indicated type, where `G` is an index
        with the same semantics as `visit()`. */
        template <size_t G, typename Self> requires (G < total_groups)
        constexpr decltype(auto) get(this Self&& self) noexcept {
            return (std::forward<Self>(self).subrange.template get<
                is_separator<G> ? 0 : normalize<G> + has_sep
            >());
        }

        /* Populate the `subrange` union with the group at index `G`.  The group can
        then be safely accessed via `get<G>()`. */
        template <size_t G> requires (!is_separator<G>)
        constexpr void init(const join_iterator& it)
            noexcept ((direction == join_direction::FORWARD && requires{
                {subrange.data = join_forward{
                    range->template arg<normalize<G>>()
                }.template begin<Sep>()} noexcept;
            }) || (direction == join_direction::REVERSE && requires{
                {subrange.data = join_reverse{
                    range->template arg<normalize<G>>()
                }.template begin<Sep>()} noexcept;
            }))
            requires ((direction == join_direction::FORWARD && requires{
                {subrange.data = join_forward{
                    range->template arg<normalize<G>>()
                }.template begin<Sep>()};
            }) || (direction == join_direction::REVERSE && requires{
                {subrange.data = join_reverse{
                    range->template arg<normalize<G>>()
                }.template begin<Sep>()};
            }))
        {
            if constexpr (direction == join_direction::FORWARD) {
                subrange.data = join_forward{
                    range->template arg<normalize<G>>()
                }.template begin<Sep>();
            } else {
                subrange.data = join_reverse{
                    range->template arg<normalize<G>>()
                }.template begin<Sep>();
            }
        }

        /* Populate the `subrange` union with the group at index `G`.  The group can
        then be safely accessed via `get<G>()`. */
        template <size_t G> requires (is_separator<G>)
        constexpr void init(const join_iterator& it)
            noexcept ((direction == join_direction::FORWARD && requires{
                {subrange.data = join_forward{range->sep()}.template begin<Sep>()} noexcept;
            }) || (direction == join_direction::REVERSE && requires{
                {subrange.data = join_reverse{range->sep()}.template begin<Sep>()} noexcept;
            }))
            requires ((direction == join_direction::FORWARD && requires{
                {subrange.data = join_forward{range->sep()}.template begin<Sep>()};
            }) || (direction == join_direction::REVERSE && requires{
                {subrange.data = join_reverse{range->sep()}.template begin<Sep>()};
            }))
        {
            if constexpr (direction == join_direction::FORWARD) {
                subrange.data = join_forward{range->sep()}.template begin<Sep>();
            } else {
                subrange.data = join_reverse{range->sep()}.template begin<Sep>();
            }
        }

        template <size_t I>
        struct deref {
            template <is_join_subrange S>
            static constexpr yield_type call(S&& s)
                noexcept (requires{{
                    *std::forward<S>(s).begin
                } noexcept -> meta::nothrow::convertible_to<yield_type>;})
                requires (requires{{
                    *std::forward<S>(s).begin
                } -> meta::convertible_to<yield_type>;})
            {
                return *std::forward<S>(s).begin;
            }

            template <is_join_nested S>
            static constexpr yield_type call(S&& s)
                noexcept (requires{{std::forward<S>(s).template visit<join_iterator::deref>(
                    std::forward<S>(s)
                )} noexcept;})
                requires (requires{{std::forward<S>(s).template visit<join_iterator::deref>(
                    std::forward<S>(s)
                )};})
            {
                return std::forward<S>(s).template visit<join_iterator::deref>(std::forward<S>(s));
            }

            template <typename P>
            [[nodiscard]] static constexpr yield_type operator()(P&& p)
                noexcept (requires{{call(std::forward<P>(p).subrange.template get<I>())} noexcept;})
                requires (requires{{call(std::forward<P>(p).subrange.template get<I>())};})
            {
                return call(std::forward<P>(p).subrange.template get<I>());
            }
        };

        template <size_t I>
        struct compare {
            template <is_join_subrange S>
            static constexpr std::strong_ordering call(const S& lhs, const S& rhs) noexcept {
                return lhs.index <=> rhs.index;
            }

            template <is_join_nested S>
            static constexpr std::strong_ordering call(const S& lhs, const S& rhs) noexcept {
                if (auto cmp = lhs.index <=> rhs.index; cmp != 0) return cmp;
                return lhs.template visit<join_iterator::compare>(lhs, rhs);
            }

            template <typename P>
            static constexpr std::strong_ordering operator()(const P& lhs, const P& rhs) noexcept {
                return call(lhs.subrange.template get<I>(), rhs.subrange.template get<I>());
            }
        };

        /// TODO: all this jump_forward/backward, increment/decrement stuff may need to
        /// pay closer attention to the index at each step, to ensure it is always
        /// valid.

        template <size_t G>
        struct jump_forward {
            template <typename S> requires (G < S::total_groups)
            static constexpr join_signal advance(const join_iterator& it, S& s)
                noexcept (requires{
                    {jump_forward<G>{}(it, s)} noexcept;
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {++s.begin} noexcept;
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires{
                    {jump_forward<G + 1>::advance(it, s)} noexcept;
                }))
                requires (requires{
                    {jump_forward<G>{}(it, s)};
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {++s.begin};
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires{
                    {jump_forward<G + 1>::advance(it, s)};
                }))
            {
                // continue depth-first search within current group, which is guaranteed
                // to be fresh and initialized to the first element
                if (jump_forward<G>{}(it, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // increment index and inner iterator
                ++s.index;
                if constexpr (is_join_nested<S> && !S::template is_separator<G>) {
                    ++s.begin;
                    if (s.begin == s.end) {
                        return join_signal::BREAK;
                    }
                }

                // try again with next group until end of current iteration
                if constexpr (G + 1 == S::total_groups) {
                    return join_signal::CONTINUE;
                } else {
                    return jump_forward<G + 1>::advance(it, s);
                }
            }

            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                })
                requires (requires{
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                })
            {
                return s.begin == s.end ? join_signal::CONTINUE : join_signal::GOOD;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {s.begin != s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {jump_forward<0>::advance(it, s)} noexcept;
                })
                requires (requires{
                    {s.begin != s.end} -> meta::convertible_to<bool>;
                    {jump_forward<0>::advance(it, s)};
                })
            {
                if (s.begin != s.end) {
                    while (true) {
                        join_signal r = jump_forward<0>::advance(it, s);
                        if (r == join_signal::GOOD) {
                            return r;
                        } else if (r == join_signal::BREAK) {
                            break;  // BREAK signal never escapes from `advance()`
                        }
                    }
                }
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, P& p)
                noexcept (requires{
                    {p.template init<G>(it)} noexcept;
                    {call(it, p.template get<G>())} noexcept;
                })
                requires (requires{
                    {p.template init<G>(it)};
                    {call(it, p.template get<G>())};
                })
            {
                p.template init<G>(it);
                return call(it, p.template get<G>());
            }
        };

        template <size_t G>
        struct increment {
            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {++s.begin} noexcept;
                    {s.begin != s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                })
                requires (requires{
                    {++s.begin};
                    {s.begin != s.end} -> meta::convertible_to<bool>;
                })
            {
                ++s.begin;
                ++s.index;
                return s.begin == s.end ? join_signal::CONTINUE : join_signal::GOOD;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {s.template visit<join_iterator::increment>(it, s)} noexcept;
                    {jump_forward<0>::advance(it, s)} noexcept;
                } && (G + 1 == S::total_groups || requires{
                    {jump_forward<G + 1>::advance(it, s)} noexcept;
                }))
                requires (requires{
                    {s.template visit<join_iterator::increment>(it, s)};
                    {jump_forward<0>::advance(it, s)};
                } && (G + 1 == S::total_groups || requires{
                    {jump_forward<G + 1>::advance(it, s)};
                }))
            {
                // recur for depth-first traversal
                if (s.template visit<join_iterator::increment>(it, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // if the inner range is exhausted, increment the outer range until we
                // find a non-empty inner range or exhaust the outer range
                join_signal r = join_signal::CONTINUE;
                if constexpr (G + 1 < S::total_groups) {
                    r = jump_forward<G + 1>::advance(it, s);
                }
                while (r != join_signal::BREAK) {
                    r = jump_forward<0>::advance(it, s);
                    if (r == join_signal::GOOD) {
                        return r;
                    }
                }

                // if we exhaust the outer range, backtrack to the previous level and
                // continue searching
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, P& p)
                noexcept (requires{{call(it, p.template get<G>())} noexcept;})
                requires (requires{{call(it, p.template get<G>())};})
            {
                return call(it, p.template get<G>());
            }
        };

        template <size_t G>
        struct jump_backward {
            template <typename S> requires (G < S::total_groups)
            static constexpr join_signal advance(const join_iterator& it, S& s)
                noexcept (requires{
                    {jump_backward<G>{}(it, s)} noexcept;
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {--s.begin} noexcept;
                }) && (G == 0 || requires{
                    {jump_backward<G - 1>::advance(it, s)} noexcept;
                }))
                requires (requires{
                    {jump_backward<G>{}(it, s)};
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {--s.begin};
                }) && (G == 0 || requires{
                    {jump_backward<G - 1>::advance(it, s)};
                }))
            {
                // continue depth-first search within current group, which is guaranteed
                // to be fresh and initialized to the last element
                if (jump_backward<G>{}(it, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // decrement index and inner iterator
                --s.index;
                if constexpr (is_join_nested<S> && !S::template is_separator<G>) {
                    if (s.index < 0) {
                        return join_signal::BREAK;
                    }
                    --s.begin;
                }

                // try again with previous group until beginning of current iteration
                if constexpr (G == 0) {
                    return join_signal::CONTINUE;
                } else {
                    return jump_backward<G - 1>::advance(it, s);
                }
            }

            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                })
                requires (requires{
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                })
            {
                return s.begin == s.end ? join_signal::CONTINUE : join_signal::GOOD;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {s.begin != s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {jump_backward<S::total_groups - 1 - S::has_sep>::advance(it, s)} noexcept;
                })
                requires (requires{
                    {s.begin != s.end} -> meta::convertible_to<bool>;
                    {jump_backward<S::total_groups - 1 - S::has_sep>::advance(it, s)};
                })
            {
                if (s.begin != s.end) {
                    while (true) {
                        // last iteration never includes final separator
                        join_signal r = jump_backward<S::total_groups - 1 - S::has_sep>::advance(
                            it,
                            s
                        );
                        if (r == join_signal::GOOD) {
                            return r;
                        } else if (r == join_signal::BREAK) {
                            break;  // BREAK signal never escapes from `advance()`
                        }
                    }
                }
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, P& p)
                noexcept (requires(decltype((p.template get<G>())) s) {
                    {p.template init<G>(it)} noexcept;
                    {p.template get<G>()} noexcept;
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {call(it, p.template get<G>())} noexcept;
                } && (
                    requires(decltype((p.template get<G>())) s) {
                        {s.index = size_t(s.end - s.begin) - 1} noexcept;
                        {s.begin += s.index} noexcept;
                    } || (
                        !requires(decltype((p.template get<G>())) s) {
                            {s.index = size_t(s.end - s.begin) - 1};
                            {s.begin += s.index};
                        } && requires(decltype((p.template get<G>())) s) {
                            {s.begin} noexcept -> meta::nothrow::copyable;
                            {++s.begin} noexcept;
                        }
                    )
                ))
                requires (requires(decltype((p.template get<G>())) s) {
                    {p.template init<G>(it)};
                    {p.template get<G>()};
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                    {call(it, p.template get<G>())};
                } && (
                    requires(decltype((p.template get<G>())) s) {
                        {s.index = size_t(s.end - s.begin) - 1};
                        {s.begin += s.index};
                    } || requires(decltype((p.template get<G>())) s) {
                        {s.begin} -> meta::copyable;
                        {++s.begin};
                    }
                ))
            {
                p.template init<G>(it);
                auto& s = p.template get<G>();
                if (s.begin == s.end) {
                    return join_signal::CONTINUE;
                }

                // initialize to last element in subrange
                using S = meta::unqualify<decltype(s)>;
                if constexpr (requires{
                    {s.index = size_t(s.end - s.begin) - 1};
                    {s.begin += s.index};
                }) {
                    s.index = size_t(s.end - s.begin) - 1;
                    s.begin += s.index;
                    if constexpr (is_join_nested<S>) {
                        s.index += (s.index - (s.index > 0)) * S::has_sep;
                    }
                } else {
                    auto next = s.begin;
                    ++next;
                    while (next != s.end) {
                        ++next;
                        ++s.begin;
                        if constexpr (is_join_nested<S>) {
                            s.index += S::total_groups;
                        } else {
                            ++s.index;
                        }
                    }
                    if constexpr (is_join_nested<S>) {
                        s.index -= S::has_sep && (s.index > 0);
                    }
                }

                return call(it, p.template get<G>());
            }
        };

        template <size_t G>
        struct decrement {
            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{{--s.begin} noexcept;})
                requires (requires{{--s.begin};})
            {
                --s.index;
                if (s.index < 0) {
                    return join_signal::CONTINUE;
                }
                --s.begin;
                return join_signal::GOOD;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, S& s)
                noexcept (requires{
                    {s.template visit<join_iterator::decrement>(it, s)} noexcept;
                    {jump_backward<S::total_groups - 1>::advance(it, s)} noexcept;
                } && (G > 0 || requires{
                    {jump_backward<G - 1>::advance(it, s)} noexcept;
                }))
                requires (requires{
                    {s.template visit<join_iterator::decrement>(it, s)};
                    {jump_backward<S::total_groups - 1>::advance(it, s)};
                } && (G > 0 || requires{
                    {jump_backward<G - 1>::advance(it, s)};
                }))
            {
                // recur for depth-first traversal
                if (s.template visit<join_iterator::decrement>(it, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // if the inner range is exhausted, decrement the outer range until we
                // find a non-empty inner range or exhaust the outer range
                join_signal r = join_signal::CONTINUE;
                if constexpr (G > 0) {
                    r = jump_backward<G - 1>::advance(it, s);
                }
                while (r != join_signal::BREAK) {
                    r = jump_backward<S::total_groups - 1>::advance(it, s);
                    if (r == join_signal::GOOD) {
                        return r;
                    }
                }

                // if we exhaust the outer range, backtrack to the previous level and
                // continue searching
                return join_signal::CONTINUE;

            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, P& p)
                noexcept (requires{{call(it, p.template get<G>())} noexcept;})
                requires (requires{{call(it, p.template get<G>())};})
            {
                return call(it, p.template get<G>());
            }
        };

        template <size_t G>
        struct seek_forward {
            template <typename S> requires (G < S::total_groups)
            static constexpr join_signal advance(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {seek_forward<G>{}(it, s)} noexcept;
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {++s.begin} noexcept;
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires{
                    {seek_forward<G + 1>::advance(it, i, s)} noexcept;
                }))
                requires (requires{
                    {seek_forward<G>{}(it, s)};
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {++s.begin};
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires{
                    {seek_forward<G + 1>::advance(it, i, s)};
                }))
            {
                // continue depth-first search within current group, which is guaranteed
                // to be fresh and initialized to the first element
                if (seek_forward<G>{}(it, i, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // increment index and inner iterator
                ++s.index;
                if constexpr (is_join_nested<S> && !S::template is_separator<G>) {
                    ++s.begin;
                    if (s.begin == s.end) {
                        return join_signal::BREAK;
                    }
                }

                // try again with next group until end of current iteration
                if constexpr (G + 1 == S::total_groups) {
                    return join_signal::CONTINUE;
                } else {
                    return seek_forward<G + 1>::advance(it, i, s);
                }
            }

            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {s.end - s.begin} noexcept -> meta::nothrow::convertible_to<difference_type>;
                    {s.begin += i} noexcept;
                })
                requires (requires{
                    {s.end - s.begin} -> std::convertible_to<difference_type>;
                    {s.begin += i};
                })
            {
                difference_type size = s.end - s.begin;
                if (i < size) {  // index falls within this innermost subrange
                    s.begin += i;
                    s.index += i;
                    return join_signal::GOOD;
                }
                i -= size;
                return join_signal::CONTINUE;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {s.begin != s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {seek_forward<0>::advance(it, i, s)} noexcept;
                })
                requires (requires{
                    {s.begin != s.end} -> meta::convertible_to<bool>;
                    {seek_forward<0>::advance(it, i, s)};
                })
            {
                if (s.begin != s.end) {
                    while (true) {
                        join_signal r = seek_forward<0>::advance(it, i, s);
                        if (r == join_signal::GOOD) {
                            return r;
                        } else if (r == join_signal::BREAK) {
                            break;
                        }
                    }
                }
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, difference_type& i, P& p)
                noexcept (requires{
                    {p.template init<G>(it)} noexcept;
                    {call(it, i, p.template get<G>())} noexcept;
                })
                requires (requires{
                    {p.template init<G>(it)};
                    {call(it, i, p.template get<G>())};
                })
            {
                p.template init<G>(it);
                return call(it, i, p.template get<G>());
            }
        };

        template <size_t G>
        struct iadd {
            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {s.end - s.begin} noexcept -> meta::nothrow::convertible_to<difference_type>;
                    {s.begin += i} noexcept;
                })
                requires (requires{
                    {s.end - s.begin} -> std::convertible_to<difference_type>;
                    {s.begin += i};
                })
            {
                difference_type size = s.end - s.begin;
                if (i < size) {  // index falls within this innermost subrange
                    s.begin += i;
                    s.index += i;
                    return join_signal::GOOD;
                }
                i -= size;
                return join_signal::CONTINUE;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {s.template visit<join_iterator::increment>(it, s)} noexcept;
                    {seek_forward<0>::advance(it, i, s)} noexcept;
                } && (G + 1 == S::total_groups || requires{
                    {seek_forward<G + 1>::advance(it, i, s)} noexcept;
                }))
                requires (requires{
                    {s.template visit<join_iterator::increment>(it, s)};
                    {seek_forward<0>::advance(it, i, s)};
                } && (G + 1 == S::total_groups || requires{
                    {seek_forward<G + 1>::advance(it, i, s)};
                }))
            {
                // recur for depth-first traversal
                if (s.template visit<join_iterator::iadd>(it, i, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // if the inner range is exhausted, increment the outer range until the
                // index falls within a future subrange or we exhaust the outer range
                join_signal r = join_signal::CONTINUE;
                if constexpr (G + 1 < S::total_groups) {
                    r = seek_forward<G + 1>::advance(it, i, s);
                }
                while (r != join_signal::BREAK) {
                    r = seek_forward<0>::advance(it, i, s);
                    if (r == join_signal::GOOD) {
                        return r;
                    }
                }

                // if we exhaust the outer range, backtrack to the previous level and
                // continue searching
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, difference_type& i, P& p)
                noexcept (requires{{call(it, i, p.template get<G>())} noexcept;})
                requires (requires{{call(it, i, p.template get<G>())};})
            {
                return call(it, i, p.template get<G>());
            }
        };

        template <size_t G>
        struct seek_backward {
            template <typename S> requires (G < S::total_groups)
            static constexpr join_signal advance(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {seek_backward<G>{}(it, s)} noexcept;
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {--s.begin} noexcept;
                }) && (G == 0 || requires{
                    {seek_backward<G - 1>::advance(it, i, s)} noexcept;
                }))
                requires (requires{
                    {seek_backward<G>{}(it, s)};
                } && (!is_join_nested<S> || S::template is_separator<G> || requires{
                    {--s.begin};
                }) && (G == 0 || requires{
                    {seek_backward<G - 1>::advance(it, i, s)};
                }))
            {
                // continue depth-first search within current group, which is guaranteed
                // to be fresh and initialized to the last element
                if (seek_backward<G>{}(it, i, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // decrement index and inner iterator
                --s.index;
                if constexpr (is_join_nested<S> && !S::template is_separator<G>) {
                    if (s.index < 0) {
                        return join_signal::BREAK;
                    }
                    --s.begin;
                }

                // try again with previous group until beginning of current iteration
                if constexpr (G == 0) {
                    return join_signal::CONTINUE;
                } else {
                    return seek_backward<G - 1>::advance(it, i, s);
                }
            }

            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{{s.begin -= i} noexcept;})
                requires (requires{{s.begin -= i};})
            {
                if (i <= s.index) {  // index falls within this innermost subrange
                    s.begin -= i;
                    s.index -= i;
                    return join_signal::GOOD;
                }
                i -= s.index;
                return join_signal::CONTINUE;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {s.begin != s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {seek_backward<S::total_groups - 1 - S::has_sep>::advance(
                        it,
                        i,
                        s
                    )} noexcept;
                    {seek_backward<S::total_groups - 1>::advance(it, i, s)} noexcept;
                })
                requires (requires{
                    {s.begin != s.end} -> meta::convertible_to<bool>;
                    {seek_backward<S::total_groups - 1 - S::has_sep>::advance(
                        it,
                        i,
                        s
                    )};
                    {seek_backward<S::total_groups - 1>::advance(it, i, s)};
                })
            {
                if (s.begin != s.end) {
                    // last iteration never includes final separator
                    join_signal r = seek_backward<S::total_groups - 1 - S::has_sep>::advance(
                        it,
                        i,
                        s
                    );
                    if (r == join_signal::GOOD) {
                        return r;
                    }
                    while (r != join_signal::BREAK) {
                        r = seek_backward<S::total_groups - 1>::advance(it, i, s);
                        if (r == join_signal::GOOD) {
                            return r;
                        }
                    }
                }
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, difference_type& i, P& p)
                noexcept (requires(decltype((p.template get<G>())) s) {
                    {p.template init<G>(it)} noexcept;
                    {p.template get<G>()} noexcept;
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {call(it, i, p.template get<G>())} noexcept;
                } && (
                    requires(decltype((p.template get<G>())) s) {
                        {s.index = size_t(s.end - s.begin) - 1} noexcept;
                        {s.begin += s.index} noexcept;
                    } || (
                        !requires(decltype((p.template get<G>())) s) {
                            {s.index = size_t(s.end - s.begin) - 1};
                            {s.begin += s.index};
                        } && requires(decltype((p.template get<G>())) s) {
                            {s.begin} noexcept -> meta::nothrow::copyable;
                            {++s.begin} noexcept;
                        }
                    )
                ))
                requires (requires(decltype((p.template get<G>())) s) {
                    {p.template init<G>(it)};
                    {p.template get<G>()};
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                    {call(it, i, p.template get<G>())};
                } && (
                    requires(decltype((p.template get<G>())) s) {
                        {s.index = size_t(s.end - s.begin) - 1};
                        {s.begin += s.index};
                    } || requires(decltype((p.template get<G>())) s) {
                        {s.begin} -> meta::copyable;
                        {++s.begin};
                    }
                ))
            {
                p.template init<G>(it);
                auto& s = p.template get<G>();
                if (s.begin == s.end) {
                    return join_signal::CONTINUE;
                }

                // initialize to last element in subrange
                using S = meta::unqualify<decltype(s)>;
                if constexpr (requires{
                    {s.index = size_t(s.end - s.begin) - 1};
                    {s.begin += s.index};
                }) {
                    s.index = size_t(s.end - s.begin) - 1;
                    s.begin += s.index;
                    if constexpr (is_join_nested<S>) {
                        s.index += (s.index - (s.index > 0)) * S::has_sep;
                    }
                } else {
                    auto next = s.begin;
                    ++next;
                    while (next != s.end) {
                        ++next;
                        ++s.begin;
                        if constexpr (is_join_nested<S>) {
                            s.index += S::total_groups;
                        } else {
                            ++s.index;
                        }
                    }
                    if constexpr (is_join_nested<S>) {
                        s.index -= S::has_sep && (s.index > 0);
                    }
                }

                return call(it, i, p.template get<G>());
            }
        };

        template <size_t G>
        struct isub {
            template <is_join_subrange S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{{s.begin -= i} noexcept;})
                requires (requires{{s.begin -= i};})
            {
                if (i <= s.index) {  // index falls within this innermost subrange
                    s.begin -= i;
                    s.index -= i;
                    return join_signal::GOOD;
                }
                i -= s.index;
                return join_signal::CONTINUE;
            }

            template <is_join_nested S> requires (G < S::total_groups)
            static constexpr join_signal call(const join_iterator& it, difference_type& i, S& s)
                noexcept (requires{
                    {s.template visit<join_iterator::isub>(it, i, s)} noexcept;
                    {seek_backward<S::total_groups - 1>::advance(it, i, s)} noexcept;
                } && (G == 0 || requires{
                    {seek_backward<G - 1>::advance(it, i, s)} noexcept;
                }))
                requires (requires{
                    {s.template visit<join_iterator::isub>(it, i, s)};
                    {seek_backward<S::total_groups - 1>::advance(it, i, s)};
                } && (G == 0 || requires{
                    {seek_backward<G - 1>::advance(it, i, s)};
                }))
            {
                // recur for depth-first traversal
                if (s.template visit<join_iterator::isub>(it, i, s) == join_signal::GOOD) {
                    return join_signal::GOOD;
                }

                // if the inner range is exhausted, decrement the outer range until the
                // index falls within a previous subrange or we exhaust the outer range
                join_signal r = join_signal::CONTINUE;
                if constexpr (G > 0) {
                    r = seek_backward<G - 1>::advance(it, i, s);
                }
                while (r != join_signal::BREAK) {
                    r = seek_backward<S::total_groups - 1>::advance(it, i, s);
                    if (r == join_signal::GOOD) {
                        return r;
                    }
                }

                // if we exhaust the outer range, backtrack to the previous level and
                // continue searching
                return join_signal::CONTINUE;
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr join_signal operator()(const join_iterator& it, difference_type& i, P& p)
                noexcept (requires{{call(it, i, p.template get<G>())} noexcept;})
                requires (requires{{call(it, i, p.template get<G>())};})
            {
                return call(it, i, p.template get<G>());
            }
        };

        /// TODO: proofread the `count` and `distance` implementations

        template <size_t G>
        struct count {
            template <is_join_nested S>
            static constexpr join_signal middle(
                difference_type& sum,
                const join_iterator& it,
                S& s
            )
                noexcept (requires(difference_type sum) {
                    {sum += count<G>{}(join_fresh{}, it, s)} noexcept;
                } && (S::template is_separator<G> || requires{
                    {++s.begin} noexcept;
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires{
                    {count<G + 1>::middle(sum, it, s)} noexcept;
                }))
                requires (requires(difference_type sum) {
                    {sum += count<G>{}(join_fresh{}, it, s)};
                } && (S::template is_separator<G> || requires{
                    {++s.begin};
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires{
                    {count<G + 1>::middle(sum, it, s)};
                }))
            {
                sum += count<G>{}(join_fresh{}, it, s);
                ++s.index;
                if constexpr (!S::template is_separator<G>) {
                    ++s.begin;
                    if (s.begin == s.end) {
                        return join_signal::BREAK;
                    }
                }
                if constexpr (G + 1 == S::total_groups) {
                    return join_signal::CONTINUE;
                } else {
                    return count<G + 1>::middle(sum, it, s);
                }
            }

            template <is_join_nested S>
            static constexpr join_signal middle(
                difference_type& sum,
                const join_iterator& it,
                S& s,
                const S& end
            )
                noexcept (requires(difference_type sum) {
                    {sum += count<G>{}(join_fresh{}, it, s)} noexcept;
                } && (S::template is_separator<G> || requires{
                    {++s.begin} noexcept;
                }) && (G + 1 == S::total_groups || requires{
                    {count<G + 1>::middle(sum, it, s, end)} noexcept;
                }))
                requires (requires(difference_type sum) {
                    {sum += count<G>{}(join_fresh{}, it, s)};
                } && (S::template is_separator<G> || requires{
                    {++s.begin};
                }) && (G + 1 == S::total_groups || requires{
                    {count<G + 1>::middle(sum, it, s, end)};
                }))
            {
                if (s.index == end.index) {
                    return join_signal::BREAK;
                }
                sum += count<G>{}(join_fresh{}, it, s);
                ++s.index;
                if constexpr (!S::template is_separator<G>) {
                    ++s.begin;
                }
                if constexpr (G + 1 == S::total_groups) {
                    return join_signal::CONTINUE;
                } else {
                    return count<G + 1>::middle(sum, it, s, end);
                }
            }

            /// NOTE: `count{}()` can be called in four different ways:
            /// 1.  `count<G>{}(join_fresh{}, it, p)`: initializes and counts group `G`
            ///     in its entirety
            /// 2.  `count<G>{}(it, p)`: counts from the current position of `p` to
            ///     the end of group `G`
            /// 3.  `count<G>{}(join_fresh{}, it, p, end)`: initializes group `G` and
            ///     counts from the beginning of `p` to the position of `end`
            /// 4.  `count<G>{}(it, p, end)`: counts from the current position of
            ///     `p` to the position of `end` (which must be in range)

            /// (1)

            template <is_join_subrange S>
            static constexpr difference_type begin_to_end(
                join_fresh,
                const join_iterator& it,
                S& s
            )
                noexcept (requires{
                    {s.end - s.begin} noexcept -> meta::nothrow::convertible_to<difference_type>;
                })
                requires (requires{
                    {s.end - s.begin} -> meta::convertible_to<difference_type>;
                })
            {
                return s.end - s.begin;
            }

            template <is_join_nested S>
            static constexpr difference_type begin_to_end(join_fresh, const join_iterator& it, S& s)
                noexcept (requires(difference_type sum) {
                    {s.begin != s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                    {count<0>::middle(sum, it, s)} noexcept;
                })
                requires (requires(difference_type sum) {
                    {s.begin != s.end} -> meta::convertible_to<bool>;
                    {count<0>::middle(sum, it, s)};
                })
            {
                difference_type sum = 0;
                if (s.begin != s.end) {
                    while (count<0>::middle(sum, it, s) != join_signal::BREAK);
                }
                return sum;
            }

            template <meta::not_const P> requires (G < P::total_groups)
            static constexpr difference_type operator()(
                join_fresh,
                const join_iterator& it,
                P& p
            )
                noexcept (requires{
                    {p.template init<G>(it)} noexcept;
                    {begin_to_end(join_fresh{}, it, p.template get<G>())} noexcept;
                })
                requires (requires{
                    {p.template init<G>(it)};
                    {begin_to_end(join_fresh{}, it, p.template get<G>())};
                })
            {
                p.template init<G>(it);
                return begin_to_end(join_fresh{}, it, p.template get<G>());
            }

            /// (2)

            template <is_join_subrange S>
            static constexpr difference_type curr_to_end(
                const join_iterator& it,
                S& s
            )
                noexcept (requires{
                    {s.end - s.begin} noexcept -> meta::nothrow::convertible_to<difference_type>;
                })
                requires (requires{
                    {s.end - s.begin} -> meta::convertible_to<difference_type>;
                })
            {
                return s.end - s.begin;
            }

            template <is_join_nested S>
            static constexpr difference_type curr_to_end(const join_iterator& it, S& s)
                noexcept (requires(difference_type sum) {
                    {s.template visit<join_iterator::count>(it, s)} noexcept;
                    {count<0>::middle(sum, it, s)} noexcept;
                } && (S::template is_separator<G> || requires{
                    {++s.begin} noexcept;
                    {s.begin == s.end} noexcept -> meta::nothrow::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires(difference_type sum) {
                    {count<G + 1>::middle(sum, it, s)} noexcept;
                }))
                requires (requires(difference_type sum) {
                    {s.template visit<join_iterator::count>(it, s)};
                    {count<0>::middle(sum, it, s)};
                } && (S::template is_separator<G> || requires{
                    {++s.begin};
                    {s.begin == s.end} -> meta::convertible_to<bool>;
                }) && (G + 1 == S::total_groups || requires(difference_type sum) {
                    {count<G + 1>::middle(sum, it, s)};
                }))
            {
                // get the distance to the end of the innermost subrange
                difference_type sum = s.template visit<join_iterator::count>(it, s);
                ++s.index;
                if constexpr (!S::template is_separator<G>) {
                    ++s.begin;
                    if (s.begin == s.end) {
                        return sum;  // skip separator after last value
                    }
                }

                // finish this iteration if necessary
                join_signal r = join_signal::CONTINUE;
                if constexpr (G + 1 < S::total_groups) {
                    r = count<G + 1>::middle(sum, it, s);
                }

                // iterate over the remaining groups
                while (r != join_signal::BREAK) {
                    r = count<0>::middle(sum, it, s);
                }
                return sum;
            }

            template <meta::not_const P> requires (G < P::total_groups)
            static constexpr difference_type operator()(const join_iterator& it, P& p)
                noexcept (requires{{curr_to_end(it, p.template get<G>())} noexcept;})
                requires (requires{{curr_to_end(it, p.template get<G>())};})
            {
                return curr_to_end(it, p.template get<G>());
            }

            /// (3)

            template <is_join_subrange S>
            static constexpr difference_type begin_to_sentinel(
                join_fresh,
                const join_iterator& it,
                S& s,
                const S& end
            )
                noexcept (requires{{
                    end.index
                } noexcept -> meta::nothrow::convertible_to<difference_type>;})
                requires (requires{{
                    end.index
                } -> meta::convertible_to<difference_type>;})
            {
                return end.index;
            }

            template <is_join_nested S>
            static constexpr difference_type begin_to_sentinel(
                join_fresh,
                const join_iterator& it,
                S& s,
                const S& end
            )
                noexcept (requires(difference_type sum) {
                    {count<0>::middle(sum, it, s)} noexcept;
                    {count<0>::middle(sum, it, s, end)} noexcept;
                    {sum + s.template visit<join_iterator::count>(it, s, end)} noexcept;
                })
                requires (requires(difference_type sum) {
                    {count<0>::middle(sum, it, s)};
                    {count<0>::middle(sum, it, s, end)};
                    {sum + s.template visit<join_iterator::count>(it, s, end)};
                })
            {
                // count full groups until `s.index` is within one group of `end.index`
                difference_type sum = 0;
                s.index += S::total_groups;
                while (s.index <= end.index) {
                    count<0>::middle(sum, it, s);
                }
                s.index -= S::total_groups;

                // continue counting last partial group until `s.index == end.index`
                count<0>::middle(sum, it, s, end);

                // recursively visit one level deeper after indices equalize
                return sum + s.template visit<join_iterator::count>(join_fresh{}, it, s, end);
            }

            template <meta::not_const P> requires (G < P::total_groups)
            static constexpr difference_type operator()(
                join_fresh,
                const join_iterator& it,
                P& p,
                const P& end
            )
                noexcept (requires{
                    {p.template init<G>(it)} noexcept;
                    {begin_to_sentinel(
                        join_fresh{},
                        it,
                        p.template get<G>(),
                        end.template get<G>()
                    )} noexcept;
                })
                requires (requires{
                    {p.template init<G>(it)};
                    {begin_to_sentinel(
                        join_fresh{},
                        it,
                        p.template get<G>(),
                        end.template get<G>()
                    )};
                })
            {
                p.template init<G>(it);
                return begin_to_sentinel(
                    join_fresh{},
                    it,
                    p.template get<G>(),
                    end.template get<G>()
                );
            }

            /// (4)

            template <is_join_subrange S>
            static constexpr difference_type curr_to_sentinel(
                const join_iterator& it,
                const S& s,
                const S& end
            )
                noexcept (requires{{
                    end.index - s.index
                } noexcept -> meta::nothrow::convertible_to<difference_type>;})
                requires (requires{{
                    end.index - s.index
                } -> meta::convertible_to<difference_type>;})
            {
                return end.index - s.index;
            }

            template <is_join_nested S>
            static constexpr difference_type curr_to_sentinel(
                const join_iterator& it,
                const S& s,
                const S& end
            )
                noexcept (
                    meta::nothrow::copyable<S> &&
                    requires(difference_type sum, S tmp) {
                        {tmp.template visit<join_iterator::count>(it, tmp)} noexcept;
                        {count<0>::middle(sum, it, tmp)} noexcept;
                        {count<0>::middle(sum, it, tmp, end)} noexcept;
                        {count<0>::middle(sum, it, tmp, s)} noexcept;
                        {tmp.template visit<join_iterator::count>(it, tmp, end)} noexcept;
                        {tmp.template visit<join_iterator::count>(it, tmp, s)} noexcept;
                        {s.template visit<join_iterator::count>(it, s, end)} noexcept;
                    } && (S::template is_separator<G> || requires(S tmp) {
                        {++tmp.begin} noexcept;
                    }) && (G + 1 == S::total_groups || requires(difference_type sum, S tmp) {
                        {count<G + 1>::middle(sum, it, tmp, end)} noexcept;
                        {count<G + 1>::middle(sum, it, tmp, s)} noexcept;
                    })
                )
                requires (
                    meta::copyable<S> &&
                    requires(difference_type sum, S tmp) {
                        {tmp.template visit<join_iterator::count>(it, tmp)};
                        {count<0>::middle(sum, it, tmp)};
                        {count<0>::middle(sum, it, tmp, end)};
                        {count<0>::middle(sum, it, tmp, s)};
                        {tmp.template visit<join_iterator::count>(it, tmp, end)};
                        {tmp.template visit<join_iterator::count>(it, tmp, s)};
                        {s.template visit<join_iterator::count>(it, s, end)};
                    } && (S::template is_separator<G> || requires(S tmp) {
                        {++tmp.begin};
                    }) && (G + 1 == S::total_groups || requires(difference_type sum, S tmp) {
                        {count<G + 1>::middle(sum, it, tmp, end)};
                        {count<G + 1>::middle(sum, it, tmp, s)};
                    })
                )
            {
                if (s.index < end.index) {
                    S tmp = s;

                    // get the distance to the end of the innermost subrange for `tmp`
                    difference_type sum = tmp.template visit<join_iterator::count>(it, tmp);
                    ++tmp.index;
                    if constexpr (!S::template is_separator<G>) {
                        ++tmp.begin;
                    }

                    // finish this iteration if necessary
                    if constexpr (G + 1 < S::total_groups) {
                        count<G + 1>::middle(sum, it, tmp, end);
                    }

                    // count full groups until `tmp.index` is within one group of `end.index`
                    tmp.index += S::total_groups;
                    while (tmp.index <= end.index) {
                        count<0>::middle(sum, it, tmp);
                    }
                    tmp.index -= S::total_groups;

                    // continue counting last partial group until `tmp.index == end.index`
                    count<0>::middle(sum, it, tmp, end);

                    // recursively visit one level deeper after indices equalize
                    return sum + tmp.template visit<join_iterator::count>(it, tmp, end);

                } else if (s.index > end.index) {
                    S tmp = end;
                    difference_type sum = -tmp.template visit<join_iterator::count>(it, tmp);
                    ++tmp.index;
                    if constexpr (!S::template is_separator<G>) {
                        ++tmp.begin;
                    }
                    difference_type temp_sum = 0;
                    if constexpr (G + 1 < S::total_groups) {
                        count<G + 1>::middle(temp_sum, it, tmp, s);
                    }
                    tmp.index += S::total_groups;
                    while (tmp.index <= s.index) {
                        count<0>::middle(temp_sum, it, tmp);
                    }
                    tmp.index -= S::total_groups;
                    count<0>::middle(temp_sum, it, tmp, s);
                    return sum - temp_sum - tmp.template visit<join_iterator::count>(it, tmp, s);

                } else {
                    // indices are already equal - just visit one level deeper
                    return s.template visit<join_iterator::count>(it, s, end);
                }
            }

            template <typename P> requires (G < P::total_groups)
            static constexpr difference_type operator()(
                const join_iterator& it,
                const P& p,
                const P& end
            )
                noexcept (requires{{curr_to_sentinel(
                    it,
                    p.template get<G>(),
                    end.template get<G>()
                )} noexcept;})
                requires (requires{{curr_to_sentinel(
                    it,
                    p.template get<G>(),
                    end.template get<G>()
                )};})
            {
                return curr_to_sentinel(it, p.template get<G>(), end.template get<G>());
            }
        };

        template <size_t H>
        struct distance {
            static constexpr size_t LHS = H / total_groups;
            static constexpr size_t RHS = H % total_groups;

            template <size_t... Gs>
            static constexpr difference_type middle(std::index_sequence<Gs...>, join_iterator& tmp)
                noexcept (requires(difference_type sum) {{(
                    (sum += count<LHS + 1 + Gs>{}(join_fresh{}, tmp, tmp)),
                    ...
                )} noexcept;})
                requires (requires(difference_type sum) {{(
                    (sum += count<LHS + 1 + Gs>{}(join_fresh{}, tmp, tmp)),
                    ...
                )};})
            {
                // a fold expression with a comma operator forces strict left-to-right
                // evaluation, which is crucial because `distance_middle` advances `tmp`
                // by side effect.
                difference_type sum = 0;
                ((sum += count<LHS + 1 + Gs>{}(join_fresh{}, tmp, tmp)), ...);
                return sum;
            }

            static constexpr difference_type operator()(
                const join_iterator& lhs,
                const join_iterator& rhs
            )
                noexcept (LHS == RHS && requires{
                    {count<LHS>{}(lhs, lhs, rhs)} noexcept;
                } && (LHS != 0 || !bidirectional || requires(join_iterator tmp) {
                    {lhs} noexcept -> meta::nothrow::copyable;
                    {rhs} noexcept -> meta::nothrow::copyable;
                    {count<LHS>{}(join_fresh{}, tmp, tmp, rhs)} noexcept;
                    {count<LHS>{}(join_fresh{}, tmp, tmp, lhs)} noexcept;
                }) && (LHS != total_groups - 1 || requires(join_iterator tmp) {
                    {lhs} noexcept -> meta::nothrow::copyable;
                    {rhs} noexcept -> meta::nothrow::copyable;
                    {count<LHS>{}(tmp, tmp)} noexcept;
                }))
                requires (LHS == RHS && requires{
                    {count<LHS>{}(lhs, lhs, rhs)};
                } && (LHS != 0 || !bidirectional || requires(join_iterator tmp) {
                    {lhs} -> meta::copyable;
                    {rhs} -> meta::copyable;
                    {count<LHS>{}(join_fresh{}, tmp, tmp, rhs)};
                    {count<LHS>{}(join_fresh{}, tmp, tmp, lhs)};
                }) && (LHS != total_groups - 1 || requires(join_iterator tmp) {
                    {lhs} -> meta::copyable;
                    {rhs} -> meta::copyable;
                    {count<LHS>{}(tmp, tmp)};
                }))
            {
                if constexpr (LHS == 0 && bidirectional) {
                    if (lhs.index < 0) {
                        join_iterator tmp = lhs;
                        return -lhs.index + count<LHS>{}(join_fresh{}, tmp, tmp, rhs);
                    }
                    if (rhs.index < 0) {
                        join_iterator tmp = rhs;
                        return rhs.index - count<LHS>{}(join_fresh{}, tmp, tmp, lhs);
                    }
                } else if constexpr (LHS == total_groups - 1) {
                    if (rhs.index >= total_groups) {
                        join_iterator tmp = lhs;
                        return rhs.index - (total_groups - 1) + count<LHS>{}(tmp, tmp);
                    }
                    if (lhs.index >= total_groups) {
                        join_iterator tmp = rhs;
                        return -(lhs.index - (total_groups - 1) + count<LHS>{}(tmp, tmp));
                    }
                }
                return count<LHS>{}(lhs, lhs, rhs);
            }

            static constexpr difference_type operator()(
                const join_iterator& lhs,
                const join_iterator& rhs
            )
                noexcept (
                    meta::nothrow::copyable<join_iterator> &&
                    requires(join_iterator tmp, difference_type sum) {
                        {sum += count<LHS>{}(tmp, tmp)} noexcept;
                        {sum += middle(std::make_index_sequence<RHS - LHS - 1>{}, tmp)} noexcept;
                        {sum += count<RHS>{}(join_fresh{}, tmp, tmp, rhs)} noexcept;
                    } && (
                        LHS > 0 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum += count<LHS>{}(join_fresh{}, tmp, tmp)} noexcept;
                        }
                    ) && (
                        RHS < total_groups - 1 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum += count<RHS>{}(join_fresh{}, tmp, tmp)} noexcept;
                        }
                    )
                )
                requires (
                    LHS < RHS &&
                    meta::copyable<join_iterator> &&
                    requires(join_iterator tmp, difference_type sum) {
                        {sum += count<LHS>{}(tmp, tmp)};
                        {sum += middle(std::make_index_sequence<RHS - LHS - 1>{}, tmp)};
                        {sum += count<RHS>{}(join_fresh{}, tmp, tmp, rhs)};
                    } && (
                        LHS > 0 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum += count<LHS>{}(join_fresh{}, tmp, tmp)};
                        }
                    ) && (
                        RHS < total_groups - 1 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum += count<RHS>{}(join_fresh{}, tmp, tmp)};
                        }
                    )
                )
            {
                join_iterator tmp = lhs;
                difference_type sum = 0;
                if constexpr (LHS == 0 && bidirectional) {
                    if (tmp.index < 0) {
                        sum -= tmp.index;
                        sum += count<LHS>{}(join_fresh{}, tmp, tmp);
                    } else {
                        sum += count<LHS>{}(tmp, tmp);
                    }
                } else {
                    sum += count<LHS>{}(tmp, tmp);
                }
                sum += middle(std::make_index_sequence<RHS - LHS - 1>{}, tmp);
                if constexpr (RHS == total_groups - 1) {
                    if (rhs.index >= total_groups) {
                        sum += rhs.index - (total_groups - 1);
                        sum += count<RHS>{}(join_fresh{}, tmp, tmp);
                    } else {
                        sum += count<RHS>{}(join_fresh{}, tmp, tmp, rhs);
                    }
                } else {
                    sum += count<RHS>{}(join_fresh{}, tmp, tmp, rhs);
                }
                return sum;
            }

            static constexpr difference_type operator()(
                const join_iterator& lhs,
                const join_iterator& rhs
            )
                noexcept (
                    meta::nothrow::copyable<join_iterator> &&
                    requires(join_iterator tmp, difference_type sum) {
                        {sum -= count<RHS>{}(tmp, tmp)} noexcept;
                        {sum -= middle(std::make_index_sequence<LHS - RHS - 1>{}, tmp)} noexcept;
                        {sum -= count<LHS>{}(join_fresh{}, tmp, tmp, lhs)} noexcept;
                    } && (
                        RHS > 0 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum -= count<RHS>{}(join_fresh{}, tmp, tmp)} noexcept;
                        }
                    ) && (
                        LHS < total_groups - 1 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum -= count<LHS>{}(join_fresh{}, tmp, tmp)} noexcept;
                        }
                    )
                )
                requires (
                    LHS > RHS &&
                    meta::copyable<join_iterator> &&
                    requires(join_iterator tmp, difference_type sum) {
                        {sum -= count<RHS>{}(tmp, tmp)};
                        {sum -= middle(std::make_index_sequence<LHS - RHS - 1>{}, tmp)};
                        {sum -= count<LHS>{}(join_fresh{}, tmp, tmp, lhs)};
                    } && (
                        RHS > 0 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum -= count<RHS>{}(join_fresh{}, tmp, tmp)};
                        }
                    ) && (
                        LHS < total_groups - 1 ||
                        !bidirectional ||
                        requires(join_iterator tmp, difference_type sum) {
                            {sum -= count<LHS>{}(join_fresh{}, tmp, tmp)};
                        }
                    )
                )
            {
                join_iterator tmp = rhs;
                difference_type sum = 0;
                if constexpr (RHS == 0 && bidirectional) {
                    if (tmp.index < 0) {
                        sum += tmp.index;
                        sum -= count<RHS>{}(join_fresh{}, tmp, tmp);
                    } else {
                        sum -= count<RHS>{}(tmp, tmp);
                    }
                } else {
                    sum -= count<RHS>{}(tmp, tmp);
                }
                sum -= middle(std::make_index_sequence<LHS - RHS - 1>{}, tmp);
                if constexpr (LHS == total_groups - 1) {
                    if (lhs.index >= total_groups) {
                        sum -= lhs.index - (total_groups - 1);
                        sum -= count<LHS>{}(join_fresh{}, tmp, tmp);
                    } else {
                        sum -= count<LHS>{}(join_fresh{}, tmp, tmp, lhs);
                    }
                } else {
                    sum -= count<LHS>{}(join_fresh{}, tmp, tmp, lhs);
                }
                return sum;
            }
        };

    public:
        [[nodiscard]] constexpr join_iterator() = default;
        [[nodiscard]] constexpr join_iterator(R range)
            noexcept (requires{{jump_forward<0>::advance(*this, *this)} noexcept;})
            requires (requires{{jump_forward<0>::advance(*this, *this)};})
        :
            range(std::addressof(range)),
            index(0)
        {
            jump_forward<0>::advance(*this, *this);
        }
        [[nodiscard]] constexpr join_iterator(R range, NoneType) noexcept :
            range(std::addressof(range)),
            index(total_groups)
        {}

        [[nodiscard]] constexpr yield_type operator*()
            noexcept (requires{{subrange.template visit<deref>(*this)} noexcept;})
            requires (requires{{subrange.template visit<deref>(*this)};})
        {
            return subrange.template visit<deref>(*this);
        }

        [[nodiscard]] constexpr yield_type operator*() const
            noexcept (requires{{subrange.template visit<deref>(*this)} noexcept;})
            requires (requires{{subrange.template visit<deref>(*this)};})
        {
            return subrange.template visit<deref>(*this);
        }

        [[nodiscard]] constexpr auto operator->()
            noexcept (requires{{impl::arrow{**this}} noexcept;})
            requires (requires{{impl::arrow{**this}};})
        {
            return impl::arrow{**this};
        }

        [[nodiscard]] constexpr auto operator->() const
            noexcept (requires{{impl::arrow{**this}} noexcept;})
            requires (requires{{impl::arrow{**this}};})
        {
            return impl::arrow{**this};
        }

        [[nodiscard]] constexpr std::strong_ordering operator<=>(const join_iterator& other) const
            noexcept
        {
            if (auto cmp = index <=> other.index; cmp != 0) return cmp;
            if (index >= total_groups || index < 0) return std::strong_ordering::equal;
            return subrange.template visit<compare>(*this, other);
        }

        [[nodiscard]] constexpr bool operator==(const join_iterator& other) const noexcept {
            return (*this <=> other) == 0;
        }

        constexpr join_iterator& operator++()
            noexcept (requires{
                {visit<increment>(*this, *this)} noexcept;
            } && (!bidirectional || requires{
                {jump_forward<0>::advance(*this, *this)} noexcept;
            }))
            requires (requires{
                {visit<increment>(*this, *this)};
            } && (!bidirectional || requires{
                {jump_forward<0>::advance(*this, *this)};
            }))
        {
            if (index >= total_groups) {
                ++index;
            } else {
                if constexpr (bidirectional) {
                    if (index < 0) {
                        ++index;
                        if (index == 0) {
                            jump_forward<0>::advance(*this, *this);
                        }
                    } else {
                        visit<increment>(*this, *this);
                    }
                } else {
                    visit<increment>(*this, *this);
                }
            }
            return *this;
        }

        [[nodiscard]] constexpr join_iterator operator++(int)
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_preincrement<join_iterator>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_preincrement<join_iterator>
            )
        {
            join_iterator tmp = *this;
            ++*this;
            return tmp;
        }

        constexpr join_iterator& operator--()
            noexcept (requires{
                {visit<decrement>(*this, *this)} noexcept;
                {jump_backward<total_groups - 1>::advance(*this, *this)} noexcept;
            })
            requires (requires{
                {visit<decrement>(*this, *this)};
                {jump_backward<total_groups - 1>::advance(*this, *this)};
            })
        {
            if (index >= total_groups) {
                --index;
                if (index == total_groups - 1) {
                    jump_backward<total_groups - 1>::advance(*this, *this);
                }
            } else if (index < 0) {
                --index;
            } else {
                visit<decrement>(*this, *this);
            }
            return *this;
        }

        [[nodiscard]] constexpr join_iterator operator--(int)
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_predecrement<join_iterator>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_predecrement<join_iterator>
            )
        {
            join_iterator tmp = *this;
            --*this;
            return tmp;
        }

        constexpr join_iterator& operator+=(difference_type i)
            noexcept (requires{
                {visit<isub>(*this, -i, *this)} noexcept;
                {visit<iadd>(*this, i, *this)} noexcept;
            } && (!bidirectional || requires{
                {seek_backward<total_groups - 1>::advance(*this, i, *this)} noexcept;
                {seek_forward<0>::advance(*this, i, *this)} noexcept;
            }))
            requires (requires{
                {visit<isub>(*this, -i, *this)};
                {visit<iadd>(*this, i, *this)};
            } && (!bidirectional || requires{
                {seek_backward<total_groups - 1>::advance(*this, i, *this)};
                {seek_forward<0>::advance(*this, i, *this)};
            }))
        {
            if (i < 0) {
                if (index < 0) {
                    index += i;
                    return *this;
                }
                join_signal r = join_signal::CONTINUE;
                if constexpr (bidirectional) {
                    if (index >= total_groups) {
                        index += i;
                        if (index < total_groups) {
                            i = total_groups - 1 - index;
                            index = total_groups - 1;
                            r = seek_backward<total_groups - 1>::advance(*this, i, *this);
                        }
                    } else {
                        r = visit<isub>(*this, -i, *this);
                    }
                } else {
                    r = visit<isub>(*this, -i, *this);
                }
                if (r != join_signal::GOOD) {
                    index -= i;  // index overflows past the beginning of the range
                };
            } else {
                if (index >= total_groups) {
                    index += i;
                    return *this;
                }
                join_signal r = join_signal::CONTINUE;
                if constexpr (bidirectional) {
                    if (index < 0) {
                        index += i;
                        if (index >= 0) {
                            i = index;
                            index = 0;
                            r = seek_forward<0>::advance(*this, i, *this);
                        }
                    } else {
                        r = visit<iadd>(*this, i, *this);
                    }
                } else {
                    r = visit<iadd>(*this, i, *this);
                }
                if (r != join_signal::GOOD) {
                    index += i;  // index overflows past the end of the range
                };
            }
            return *this;
        }

        [[nodiscard]] constexpr join_iterator& operator-=(difference_type i)
            noexcept (requires{{*this += -i} noexcept;})
            requires (requires{{*this += -i};})
        {
            return *this += -i;
        }

        [[nodiscard]] friend constexpr join_iterator operator+(
            const join_iterator& self,
            difference_type i
        )
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_iadd<join_iterator, difference_type>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_iadd<join_iterator, difference_type>
            )
        {
            join_iterator result = self;
            result += i;
            return result;
        }

        [[nodiscard]] friend constexpr join_iterator operator+(
            difference_type i,
            const join_iterator& self
        )
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_iadd<join_iterator, difference_type>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_iadd<join_iterator, difference_type>
            )
        {
            join_iterator result = self;
            result += i;
            return result;
        }

        [[nodiscard]] constexpr join_iterator operator-(difference_type i) const
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_isub<join_iterator, difference_type>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_isub<join_iterator, difference_type>
            )
        {
            join_iterator result = *this;
            result -= i;
            return result;
        }

        [[nodiscard]] constexpr yield_type operator[](difference_type i)
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_iadd<join_iterator, difference_type> &&
                meta::nothrow::has_dereference<join_iterator>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_iadd<join_iterator, difference_type> &&
                meta::has_dereference<join_iterator>
            )
        {
            join_iterator temp = *this;
            temp += i;
            return *temp;
        }

        [[nodiscard]] constexpr yield_type operator[](difference_type i) const
            noexcept (
                meta::nothrow::copyable<join_iterator> &&
                meta::nothrow::has_iadd<join_iterator, difference_type> &&
                meta::nothrow::has_dereference<join_iterator>
            )
            requires (
                meta::copyable<join_iterator> &&
                meta::has_iadd<join_iterator, difference_type> &&
                meta::has_dereference<join_iterator>
            )
        {
            join_iterator temp = *this;
            temp += i;
            return *temp;
        }

        [[nodiscard]] constexpr difference_type operator-(const join_iterator& other) const
            noexcept (requires{{
                impl::basic_vtable<distance, total_groups * total_groups>{
                    size_t(index * total_groups + other.index)
                }(*this, other)
            } noexcept;})
            requires (requires{{
                impl::basic_vtable<distance, total_groups * total_groups>{
                    size_t(index * total_groups + other.index)
                }(*this, other)
            };})
        {
            ssize_t l = index;
            ssize_t r = other.index;

            // if both iterators are out of bounds and in the same region, then the
            // distance is simply the difference between their overflowing indices
            if constexpr (bidirectional) {
                if (l < 0) {
                    if (r < 0) return l - r;
                    l = 0;
                    if (r >= total_groups) r = total_groups - 1;
                } else if (l >= total_groups) {
                    if (r >= total_groups) return l - r;
                    l = total_groups - 1;
                    if (r < 0) r = 0;
                } else if (r < 0) {
                    r = 0;
                } else if (r >= total_groups) {
                    r = total_groups - 1;
                }
            } else {
                if (l >= total_groups) {
                    if (r >= total_groups) return l - r;
                    l = total_groups - 1;
                } else if (r >= total_groups) {
                    r = total_groups - 1;
                }
            }

            // otherwise we dispatch based on the cartesian product of the normalized
            // indices, which effectively promotes them to compile time, allowing the
            // rest of the logic to index on that basis
            return impl::basic_vtable<distance, total_groups * total_groups>{
                size_t(l * total_groups + r)
            }(*this, other);
        }
    };

    /* `make_join_iterator` produces a `join_iterator` containing forward iterators
    over a `join` container.  It is responsible for deducing the proper subrange types
    and specializing the `join_iterator` template accordingly, such that the public
    `begin()` and `end()` methods for joined ranges devolve to
    `make_join_iterator{*this}.begin()` and `make_join_iterator{*this}.end()`,
    respectively. */
    template <meta::lvalue R, typename>
    struct _make_join_iterator;
    template <meta::lvalue R, size_t... Is>
    struct _make_join_iterator<R, std::index_sequence<Is...>> {
        using type = join_iterator<
            R,
            void,
            decltype(join_forward{std::declval<R>().template arg<Is>()}.template begin<void>())...
        >;
    };
    template <meta::lvalue R, size_t... Is>
        requires (meta::not_void<typename meta::unqualify<R>::separator_type>)
    struct _make_join_iterator<R, std::index_sequence<Is...>> {
        using separator = decltype(join_forward{std::declval<R>().sep()}.template begin<void>());
        using type = join_iterator<
            R,
            separator,
            decltype(join_forward{
                std::declval<R>().template arg<Is>()
            }.template begin<separator>())...
        >;
    };
    template <meta::lvalue R>
    struct make_join_iterator {
        using begin_type = _make_join_iterator<R, typename meta::unqualify<R>::indices>;
        using end_type = begin_type;

        R range;

        [[nodiscard]] constexpr begin_type begin()
            noexcept (requires{{begin_type(range)} noexcept;})
            requires (requires{{begin_type(range)};})
        {
            return begin_type(range);
        }

        [[nodiscard]] constexpr end_type end()
            noexcept (requires{{end_type(range, None)} noexcept;})
            requires (requires{{end_type(range, None)};})
        {
            return end_type(range, None);
        }
    };
    template <typename R>
    make_join_iterator(R&) -> make_join_iterator<R&>;

    /* `make_join_reversed` works identically to `make_join_iterator`, except that the
    subranges encapsulate reverse iterators rather than forward ones. */
    template <meta::lvalue R, typename>
    struct _make_join_reversed;
    template <meta::lvalue R, size_t... Is>
    struct _make_join_reversed<R, std::index_sequence<Is...>> {
        using type = join_iterator<
            R,
            void,
            decltype(join_reverse{
                std::declval<R>().template arg<Is>()
            }.template begin<void>())...
        >;
    };
    template <meta::lvalue R, size_t... Is>
        requires (meta::not_void<typename meta::unqualify<R>::separator_type>)
    struct _make_join_reversed<R, std::index_sequence<Is...>> {
        using separator = decltype(join_reverse{std::declval<R>().sep()}.template begin<void>());
        using type = join_iterator<
            R,
            separator,
            decltype(join_reverse{
                std::declval<R>().template arg<Is>()
            }.template begin<separator>())...
        >;
    };
    template <meta::lvalue R>
        requires (range_reverse_iterable<typename meta::unqualify<R>::argument_types>)
    struct make_join_reversed {
        using begin_type = _make_join_reversed<R, typename meta::unqualify<R>::indices>::type;
        using end_type = begin_type;

        R range;

        [[nodiscard]] constexpr begin_type begin()
            noexcept (requires{{begin_type(range)} noexcept;})
            requires (requires{{begin_type(range)};})
        {
            return begin_type(range);
        }

        constexpr end_type end()
            noexcept (requires{{end_type(range, None)} noexcept;})
            requires (requires{{end_type(range, None)};})
        {
            return end_type(range, None);
        }
    };
    template <typename R>
    make_join_reversed(R&) -> make_join_reversed<R&>;

    /* The type returned by the subscript operator for joined ranges may need to be a
    union if any of the subscript types differ.  If a separator is provided, then its
    subscript type must also be included in the union.  If all of the subscript types
    are the same, then the union will collapse into a single type, and the `trivial`
    flag will be set to true. */
    template <typename R, typename>
    struct _join_subscript_type;
    template <typename R, size_t... Is>
        requires (meta::is_void<typename meta::unqualify<R>::separator_type>)
    struct _join_subscript_type<R, std::index_sequence<Is...>> {
        using type = meta::make_union<
            decltype((std::declval<R>().template arg<Is>()[
                std::declval<typename meta::unqualify<R>::size_type>()
            ]))...
        >;
        static constexpr bool trivial = meta::trivial_union<
            decltype((std::declval<R>().template arg<Is>()[
                std::declval<typename meta::unqualify<R>::size_type>()
            ]))...
        >;
    };
    template <typename R, size_t... Is>
        requires (meta::not_void<typename meta::unqualify<R>::separator_type>)
    struct _join_subscript_type<R, std::index_sequence<Is...>> {
        using type = meta::make_union<
            decltype((std::declval<R>().sep()[
                std::declval<typename meta::unqualify<R>::size_type>()
            ])),
            decltype((std::declval<R>().template arg<Is>()[
                std::declval<typename meta::unqualify<R>::size_type>()
            ]))...
        >;
        static constexpr bool trivial = meta::trivial_union<
            decltype((std::declval<R>().sep()[
                std::declval<typename meta::unqualify<R>::size_type>()
            ])),
            decltype((std::declval<R>().template arg<Is>()[
                std::declval<typename meta::unqualify<R>::size_type>()
            ]))...
        >;
    };
    template <typename R>
    using join_subscript_type = _join_subscript_type<R, typename meta::unqualify<R>::indices>;

    template <typename Sep>
    constexpr size_t join_sep_size = 1;
    template <meta::is_void Sep>
    constexpr size_t join_sep_size<Sep> = 0;
    template <meta::range Sep> requires (meta::tuple_like<Sep>)
    constexpr size_t join_sep_size<Sep> = meta::tuple_size<Sep>;
    template <join_flatten Sep>
        requires (meta::tuple_like<Sep> && meta::tuple_like<meta::yield_type<Sep>>)
    constexpr size_t join_sep_size<Sep> =
        meta::tuple_size<Sep> * meta::tuple_size<meta::yield_type<Sep>>;

    template <typename T, typename Sep>
    constexpr size_t join_arg_size = 1;
    template <meta::range T, typename Sep> requires (meta::tuple_like<T>)
    constexpr size_t join_arg_size<T, Sep> = meta::tuple_size<T>;
    template <join_flatten T, typename Sep>
        requires (meta::tuple_like<T> && meta::tuple_like<meta::yield_type<T>>)
    constexpr size_t join_arg_size<T, Sep> =
        meta::tuple_size<meta::yield_type<T>> * meta::tuple_size<T> +
        join_sep_size<Sep> * (meta::tuple_size<T> - (meta::tuple_size<T> > 0));

    template <typename Sep, typename... A>
    constexpr size_t join_tuple_size = (
        join_arg_size<A, Sep> +
        ... +
        (join_sep_size<Sep> * (sizeof...(A) - (sizeof...(A) > 0))
    ));

    /* Joined ranges store an arbitrary set of argument types as well as a possible
    separator to insert between each one.  The arguments are not required to be ranges,
    and will be inserted as single elements at their respective position if not.  If
    any of the arguments are ranges, then they will be iterated over in sequence. */
    template <meta::unqualified Sep, meta::not_rvalue... A> requires (meta::is_pack<Sep>)
    struct join {
        using separator_type = Sep;
        using argument_types = meta::pack<A...>;
        using size_type = size_t;
        using index_type = ssize_t;
        using indices = std::make_index_sequence<sizeof...(A)>;
        using ranges = range_indices<A...>;

        [[no_unique_address]] Sep::template eval<impl::basic_tuple> seps;
        [[no_unique_address]] impl::basic_tuple<A...> args;

        /// TODO: eliminate all mentions of `m_storage`

        /* Perfectly forward the stored separator, if one was given. */
        template <typename Self> requires (meta::not_void<Sep>)
        [[nodiscard]] constexpr decltype(auto) sep(this Self&& self) noexcept {
            return (*std::forward<Self>(self).m_storage.sep);
        }

        /* Perfectly forward the I-th joined argument. */
        template <size_t I, typename Self> requires (I < sizeof...(A))
        [[nodiscard]] constexpr decltype(auto) arg(this Self&& self) noexcept {
            return (std::forward<Self>(self).m_storage.args.template get<I>());
        }

    private:
        static constexpr bool sized = (
            (!meta::range<Sep> || (meta::has_size<Sep> && (
                !join_flatten<Sep> || meta::tuple_like<meta::yield_type<Sep>>
            ))) &&
            ... &&
            (!meta::range<A> || (meta::has_size<A> && (
                !join_flatten<A> || meta::tuple_like<meta::yield_type<A>>
            )))
        );
        static constexpr bool tuple_like = (
            (!meta::range<Sep> || meta::tuple_like<Sep>) &&
            ... &&
            (!meta::range<A> || meta::tuple_like<A>)
        );

        template <size_t J>
        static constexpr size_type unpack_size =
            meta::tuple_size<meta::yield_type<meta::unpack_type<J, A...>>>;

        template <typename T>
        constexpr size_type size_impl(const T& arg) const
            noexcept (
                !meta::range<T> ||
                (meta::nothrow::size_returns<size_type, const T&> && (
                    !join_flatten<T> ||
                    (meta::tuple_like<meta::yield_type<T>> && (
                        !meta::range<Sep> ||
                        requires{{size_type(sep().size())} noexcept;}
                    ))
                ))
            )
            requires (
                !meta::range<T> ||
                (meta::size_returns<size_type, const T&> && (
                    !join_flatten<T> ||
                    (meta::tuple_like<meta::yield_type<T>> && (
                        !meta::range<Sep> ||
                        requires{{size_type(sep().size())};}
                    ))
                ))
            )
        {
            if constexpr (join_flatten<T>) {
                constexpr size_type element_size = meta::tuple_size<meta::yield_type<T>>;
                size_type n = arg.size();
                if constexpr (meta::is_void<Sep>) {
                    return n * element_size;
                } else if constexpr (meta::range<Sep>) {
                    return n * element_size + (n - (n > 0)) * size_type(sep().size());
                } else {
                    return n * element_size + (n - (n > 0));
                }
            } else if constexpr (meta::range<T>) {
                return arg.size();
            } else {
                return 1;
            }
        }

        template <size_t... Is> requires (sizeof...(Is) == indices::size())
        constexpr size_type _size(std::index_sequence<Is...>) const
            noexcept (requires{{(size_impl(arg<Is>()) + ... + 0)} noexcept;})
            requires (meta::is_void<Sep> && requires{{(size_impl(arg<Is>()) + ... + 0)};})
        {
            return (size_impl(arg<Is>()) + ... + 0);
        }

        template <size_t... Is> requires (sizeof...(Is) == indices::size())
        constexpr size_type _size(std::index_sequence<Is...>) const
            noexcept (requires{{(
                size_impl(arg<Is>()) +
                ... +
                (size_type(sep().size()) * (sizeof...(Is) - (sizeof...(Is) > 0)))
            )} noexcept;})
            requires (meta::range<Sep> && requires{{(
                size_impl(arg<Is>()) +
                ... +
                (size_type(sep().size()) * (sizeof...(Is) - (sizeof...(Is) > 0)))
            )};})
        {
            return (
                size_impl(arg<Is>()) +
                ... +
                (size_type(sep().size()) * (sizeof...(Is) - (sizeof...(Is) > 0)))
            );
        }

        template <size_t... Is> requires (sizeof...(Is) == indices::size())
        constexpr size_type _size(std::index_sequence<Is...>) const
            noexcept (requires{{(
                size_impl(arg<Is>()) +
                ... +
                (sizeof...(Is) - (sizeof...(Is) > 0))
            )} noexcept;})
            requires (meta::not_void<Sep> && !meta::range<Sep> && requires{{(
                size_impl(arg<Is>()) +
                ... +
                (sizeof...(Is) - (sizeof...(Is) > 0))
            )};})
        {
            return (
                size_impl(arg<Is>()) +
                ... +
                (sizeof...(Is) - (sizeof...(Is) > 0))
            );
        }

    public:
        /* The overall size of the joined range as an unsigned integer.  This is only
        enabled if all of the arguments are either sized ranges or non-range inputs,
        and the separator is either absent, a scalar value, or a sized range.  If one
        or more unpacking operators are used, then the unpacked element type must be
        either scalar or tuple-like, so that the size can be computed in constant time.
        Otherwise, this method will fail to compile. */
        [[nodiscard]] static constexpr size_type size() noexcept requires (tuple_like) {
            return join_tuple_size<Sep, A...>;
        }

        /* The overall size of the joined range as an unsigned integer.  This is only
        enabled if all of the arguments are either sized ranges or non-range inputs,
        and the separator is either absent, a scalar value, or a sized range.  If one
        or more unpacking operators are used, then the unpacked element type must be
        either scalar or tuple-like, so that the size can be computed in constant time.
        Otherwise, this method will fail to compile. */
        [[nodiscard]] constexpr size_type size() const
            noexcept (requires{{_size(indices{})} noexcept;})
            requires (!tuple_like && sized)
        {
            return _size(indices{});
        }

        /* The overall size of the joined range as a signed integer.  This is only
        enabled if all of the arguments are either sized ranges or non-range inputs,
        and the separator is either absent, a scalar value, or a sized range. */
        [[nodiscard]] constexpr index_type ssize() const
            noexcept (requires{{index_type(size())} noexcept;})
            requires (sized)
        {
            return index_type(size());
        }

        /* True if the joined range contains no elements.  False otherwise. */
        [[nodiscard]] constexpr bool empty() const
            noexcept (requires{{begin() == end()} noexcept;})
        {
            return begin() == end();
        }

    private:
        template <size_t I> requires (I < sizeof...(A))
        static constexpr bool broadcast = !meta::range<meta::unpack_type<I, A...>>;

        template <size_t I> requires (I < sizeof...(A))
        static constexpr bool flatten = join_flatten<meta::unpack_type<I, A...>>;

        template <typename Self>
        using subscript_type = join_subscript_type<Self>::type;

        template <size_t I, typename Self> requires (I < join_sep_size<Sep>)
        constexpr decltype(auto) get_sep_impl(this Self&& self)
            noexcept ((join_flatten<Sep> && requires{
                {std::forward<Self>(self).sep().
                    template get<I / meta::tuple_size<meta::yield_type<Sep>>>().
                    template get<I % meta::tuple_size<meta::yield_type<Sep>>>()
                } noexcept;
            }) || (!join_flatten<Sep> && meta::range<Sep> && requires{
                {std::forward<Self>(self).sep().template get<I>()} noexcept;
            }) || (!meta::range<Sep> && requires{
                {std::forward<Self>(self).sep()} noexcept;
            }))
            requires ((join_flatten<Sep> && requires{
                {std::forward<Self>(self).sep().
                    template get<I / meta::tuple_size<meta::yield_type<Sep>>>().
                    template get<I % meta::tuple_size<meta::yield_type<Sep>>>()
                };
            }) || (!join_flatten<Sep> && meta::range<Sep> && requires{
                {std::forward<Self>(self).sep().template get<I>()};
            }) || (!meta::range<Sep> && requires{
                {std::forward<Self>(self).sep()};
            }))
        {
            if constexpr (join_flatten<Sep>) {
                return (std::forward<Self>(self).sep().
                    template get<I / meta::tuple_size<meta::yield_type<Sep>>>().
                    template get<I % meta::tuple_size<meta::yield_type<Sep>>>()
                );
            } else if constexpr (meta::range<Sep>) {
                return (std::forward<Self>(self).sep().template get<I>());
            } else {
                return (std::forward<Self>(self).sep());
            }
        }

        /* Index `I` matches a separator. */
        template <size_t I, size_t J, typename Self> requires (I < join_sep_size<Sep>)
        constexpr decltype(auto) get_sep(this Self&& self)
            noexcept (requires{{std::forward<Self>(self).template get_sep_impl<I>()} noexcept;})
            requires (requires{{std::forward<Self>(self).template get_sep_impl<I>()};})
        {
            return std::forward<Self>(self).template get_sep_impl<I>();
        }

        template <size_t I, size_t J, typename Self>
        static constexpr size_t quotient = 
            (join_sep_size<Sep> + I) / (join_sep_size<Sep> + unpack_size<J>);

        template <size_t I, size_t J, typename Self>
        static constexpr size_t remainder =
            (join_sep_size<Sep> + I) % (join_sep_size<Sep> + unpack_size<J>);

        /* Index `I` matches the `J`-th joined argument, accounting for separators. */
        template <size_t I, size_t J, typename Self>
            requires (I < join_arg_size<meta::unpack_type<J, A...>, Sep>)
        constexpr decltype(auto) _get(this Self&& self)
            noexcept ((flatten<J> && (
                (
                    remainder<I, J, Self> < join_sep_size<Sep> &&
                    requires{{std::forward<Self>(self).
                        template get_sep_impl<remainder<I, J, Self>>()
                    } noexcept;}
                ) || (
                    remainder<I, J, Self> >= join_sep_size<Sep> &&
                    requires{{std::forward<Self>(self).template arg<J>().
                        template get<quotient<I, J, Self>>().
                        template get<remainder<I, J, Self> - join_sep_size<Sep>>()
                    } noexcept;}
                )
            )) || (!flatten<J> && !broadcast<J> && requires{
                {std::forward<Self>(self).template arg<J>().template get<I>()} noexcept;
            }) || (broadcast<J> && requires{
                {std::forward<Self>(self).template arg<J>()} noexcept;
            }))
            requires ((flatten<J> && (
                (
                    remainder<I, J, Self> < join_sep_size<Sep> &&
                    requires{{std::forward<Self>(self).
                        template get_sep_impl<remainder<I, J, Self>>()
                    };}
                ) || (
                    remainder<I, J, Self> >= join_sep_size<Sep> &&
                    requires{{std::forward<Self>(self).template arg<J>().
                        template get<quotient<I, J, Self>>().
                        template get<remainder<I, J, Self> - join_sep_size<Sep>>()
                    };}
                )
            )) || (!flatten<J> && !broadcast<J> && requires{
                {std::forward<Self>(self).template arg<J>().template get<I>()} noexcept;
            }) || (broadcast<J> && requires{
                {std::forward<Self>(self).template arg<J>()} noexcept;
            }))
        {
            if constexpr (flatten<J>) {
                constexpr size_t r = remainder<I, J, Self>;
                if constexpr (r < join_sep_size<Sep>) {
                    return (std::forward<Self>(self).template get_sep_impl<r>());
                } else {
                    return (std::forward<Self>(self).template arg<J>().
                        template get<quotient<I, J, Self>>().
                        template get<r - join_sep_size<Sep>>()
                    );
                }
            } else if constexpr (!broadcast<J>) {
                return (std::forward<Self>(self).template arg<J>().template get<I>());
            } else {
                return (std::forward<Self>(self).template arg<J>());
            }
        }

        /* Index `I` does NOT match the `J-th` joined argument. */
        template <size_t I, size_t J, typename Self>
            requires (I >= join_arg_size<meta::unpack_type<J, A...>, Sep>)
        constexpr decltype(auto) _get(this Self&& self)
            noexcept (requires{{std::forward<Self>(self).template get_sep<
                I - join_arg_size<meta::unpack_type<J, A...>, Sep>,
                J + 1
            >()} noexcept;})
            requires (requires{{std::forward<Self>(self).template get_sep<
                I - join_arg_size<meta::unpack_type<J, A...>, Sep>,
                J + 1
            >()};})
        {
            return (std::forward<Self>(self).template get_sep<
                I - join_arg_size<meta::unpack_type<J, A...>, Sep>,
                J + 1
            >());
        }

        /* Index `I` does NOT match the current separator. */
        template <size_t I, size_t J, typename Self> requires (I >= join_sep_size<Sep>)
        constexpr decltype(auto) get_sep(this Self&& self)
            noexcept (requires{{
                std::forward<Self>(self).template _get<I - join_sep_size<Sep>, J>()
            } noexcept;})
            requires (requires{{
                std::forward<Self>(self).template _get<I - join_sep_size<Sep>, J>()
            };})
        {
            return (std::forward<Self>(self).template _get<I - join_sep_size<Sep>, J>());
        }

        constexpr size_type subscript_sep_size() const
            noexcept (
                !meta::range<Sep> ||
                (join_flatten<Sep> && requires{{
                    sep().size() * meta::tuple_size<meta::yield_type<Sep>>
                } noexcept -> meta::nothrow::convertible_to<size_type>;}) ||
                (!join_flatten<Sep> && requires{
                    {sep().size()} noexcept -> meta::nothrow::convertible_to<size_type>;
                })
            )
            requires (meta::not_void<Sep> && (
                !meta::range<Sep> ||
                (join_flatten<Sep> && requires{{
                    sep().size() * meta::tuple_size<meta::yield_type<Sep>>
                } -> meta::convertible_to<size_type>;}) ||
                (!join_flatten<Sep> && requires{
                    {sep().size()} -> meta::convertible_to<size_type>;
                })
            ))
        {
            if constexpr (join_flatten<Sep>) {
                return sep().size() * meta::tuple_size<meta::yield_type<Sep>>;
            } else if constexpr (meta::range<Sep>) {
                return sep().size();
            } else {
                return 1;
            }
        }

        template <size_t J>
        constexpr size_type subscript_size() const
            noexcept (
                broadcast<J> ||
                (
                    flatten<J> &&
                    requires{
                        {arg<J>().size()} noexcept -> meta::nothrow::convertible_to<size_type>;
                    } && (meta::is_void<Sep> || requires{{subscript_sep_size()} noexcept;})
                ) || (
                    !flatten<J> &&
                    requires{
                        {arg<J>().size()} noexcept -> meta::nothrow::convertible_to<size_type>;
                    }
                )
            )
            requires (
                broadcast<J> ||
                (
                    flatten<J> &&
                    requires{
                        {arg<J>().size()} -> meta::convertible_to<size_type>;
                    } && (meta::is_void<Sep> || requires{{subscript_sep_size()};})
                ) || (
                    !flatten<J> &&
                    requires{
                        {arg<J>().size()} -> meta::convertible_to<size_type>;
                    }
                )
            )
        {
            if constexpr (flatten<J>) {
                size_type n = arg<J>().size();
                if constexpr (meta::not_void<Sep>) {
                    return n * unpack_size<J> + (n - (n > 0)) * subscript_sep_size();
                } else {
                    return n * unpack_size<J>;
                }
            } else if constexpr (!broadcast<J>) {
                return arg<J>().size();
            } else {
                return 1;
            }
        }

        template <typename Self> requires (meta::not_void<Sep>)
        constexpr subscript_type<Self> subscript_sep(this Self&& self, size_type i)
            noexcept (
                (join_flatten<Sep> && requires{
                    {
                        std::forward<Self>(self).sep()
                            [i / meta::tuple_size<meta::yield_type<Sep>>()]
                            [i % meta::tuple_size<meta::yield_type<Sep>>()]
                    } noexcept -> meta::nothrow::convertible_to<subscript_type<Self>>;
                }) || (!join_flatten<Sep> && meta::range<Sep> && requires{
                    {
                        std::forward<Self>(self).sep()[i]
                    } noexcept -> meta::nothrow::convertible_to<subscript_type<Self>>;
                }) || (!meta::range<Sep> && requires{
                    {
                        std::forward<Self>(self).sep()
                    } noexcept -> meta::nothrow::convertible_to<subscript_type<Self>>;
                })
            )
            requires (
                (join_flatten<Sep> && requires{
                    {
                        std::forward<Self>(self).sep()
                            [i / meta::tuple_size<meta::yield_type<Sep>>()]
                            [i % meta::tuple_size<meta::yield_type<Sep>>()]
                    } -> meta::convertible_to<subscript_type<Self>>;
                }) || (!join_flatten<Sep> && meta::range<Sep> && requires{
                    {
                        std::forward<Self>(self).sep()[i]
                    } -> meta::convertible_to<subscript_type<Self>>;
                }) || (!meta::range<Sep> && requires{
                    {
                        std::forward<Self>(self).sep()
                    } -> meta::convertible_to<subscript_type<Self>>;
                })
            )
        {
            if constexpr (join_flatten<Sep>) {
                constexpr size_type n = meta::tuple_size<meta::yield_type<Sep>>;
                return std::forward<Self>(self).sep()[i / n][i % n];
            } else if constexpr (meta::range<Sep>) {
                return std::forward<Self>(self).sep()[i];
            } else {
                return std::forward<Self>(self).sep();
            }
        }

        template <size_t J, typename Self> requires (J < sizeof...(A))
        constexpr subscript_type<Self> subscript(this Self&& self, size_type i)
            noexcept (requires{{self.template subscript_size<J>()} noexcept;} && (
                meta::is_void<Sep> || requires{
                    {self.subscript_sep_size()} noexcept;
                    {std::forward<Self>(self).subscript_sep(i)} noexcept;
                }
            ) && (
                (
                    flatten<J> && requires{{
                        std::forward<Self>(self).template arg<J>()[i][i]
                    } noexcept -> meta::nothrow::convertible_to<subscript_type<Self>>;}
                ) || (
                    !flatten<J> && !broadcast<J> &&
                    requires{{
                        std::forward<Self>(self).template arg<J>()[i]
                    } noexcept -> meta::nothrow::convertible_to<subscript_type<Self>>;}
                ) || (
                    broadcast<J> &&
                    requires{{
                        std::forward<Self>(self).template arg<J>()
                    } noexcept -> meta::nothrow::convertible_to<subscript_type<Self>>;}
                )
            ) && (
                J + 1 >= sizeof...(A) || requires{
                    {std::forward<Self>(self).template subscript<J + 1>(i)} noexcept;
                }
            ))
            requires (requires{{self.template subscript_size<J>()};} && (
                meta::is_void<Sep> || requires{
                    {self.subscript_sep_size()};
                    {std::forward<Self>(self).subscript_sep(i)};
                }
            ) && (
                (
                    flatten<J> && requires{{
                        std::forward<Self>(self).template arg<J>()[i][i]
                    } -> meta::convertible_to<subscript_type<Self>>;}
                ) || (
                    !flatten<J> && !broadcast<J> &&
                    requires{{
                        std::forward<Self>(self).template arg<J>()[i]
                    } -> meta::convertible_to<subscript_type<Self>>;}
                ) || (
                    broadcast<J> &&
                    requires{{
                        std::forward<Self>(self).template arg<J>()
                    } -> meta::convertible_to<subscript_type<Self>>;}
                )
            ) && (
                J + 1 >= sizeof...(A) || requires{
                    {std::forward<Self>(self).template subscript<J + 1>(i)};
                }
            ))
        {
            size_type size = self.template subscript_size<J>();
            if (i < size) {
                if constexpr (flatten<J>) {
                    if constexpr (meta::not_void<Sep>) {
                        size_type sep_size = self.subscript_sep_size();
                        i += sep_size;
                        size_type j = i / (sep_size + unpack_size<J>);
                        i %= (sep_size + unpack_size<J>);
                        if (i < sep_size) {
                            return std::forward<Self>(self).subscript_sep(i);
                        }
                        return std::forward<Self>(self).template arg<J>()[j][i - sep_size];
                    } else {
                        constexpr size_type n = unpack_size<J>;
                        return std::forward<Self>(self).template arg<J>()[i / n][i % n];
                    }
                } else if constexpr (!broadcast<J>) {
                    return std::forward<Self>(self).template arg<J>()[i];
                } else {
                    return std::forward<Self>(self).template arg<J>();
                }
            }
            if constexpr (J + 1 < sizeof...(A)) {
                i -= size;
                if constexpr (meta::not_void<Sep>) {
                    size_type sep_size = self.subscript_sep_size();
                    if (i < sep_size) {
                        return std::forward<Self>(self).subscript_sep(i);
                    }
                    i -= sep_size;
                }
                return std::forward<Self>(self).template subscript<J + 1>(i);
            } else {
                throw IndexError();  // unreachable
            }
        }

    public:
        /* Access the `I`-th element of a tuple-like, joined range.  Non-range
        arguments will be forwarded according to the current cvref qualifications of
        the `join` range, while range arguments will be accessed using the provided
        index before forwarding.  If the index is invalid for one or more of the input
        ranges, then this method will fail to compile. */
        template <size_t I, typename Self> requires (tuple_like && I < join_tuple_size<Sep, A...>)
        [[nodiscard]] constexpr decltype(auto) get(this Self&& self)
            noexcept (requires{{std::forward<Self>(self).template _get<I, 0>()} noexcept;})
            requires (requires{{std::forward<Self>(self).template _get<I, 0>()};})
        {
            return (std::forward<Self>(self).template _get<I, 0>());
        }

        /* Index into the joined range.  Non-range arguments will be forwarded
        according to the current cvref qualifications of the `join` range, while range
        arguments will be accessed using the provided index before forwarding.  If the
        index is not supported for one or more of the input ranges, then this method
        will fail to compile. */
        template <typename Self>
        [[nodiscard]] constexpr subscript_type<Self> operator[](this Self&& self, size_type i)
            noexcept (requires{{std::forward<Self>(self).template subscript<0>(i)} noexcept;})
            requires (requires{{std::forward<Self>(self).template subscript<0>(i)};})
        {
            return std::forward<Self>(self).template subscript<0>(i);
        }
        
        /* Get a forward iterator over the joined range. */
        [[nodiscard]] constexpr auto begin()
            noexcept (requires{{make_join_iterator{*this}.begin()} noexcept;})
            requires (requires{{make_join_iterator{*this}.begin()};})
        {
            return make_join_iterator{*this}.begin();
        }

        /* Get a forward iterator over the joined range. */
        [[nodiscard]] constexpr auto begin() const
            noexcept (requires{{make_join_iterator{*this}.begin()} noexcept;})
            requires (requires{{make_join_iterator{*this}.begin()};})
        {
            return make_join_iterator{*this}.begin();
        }

        /* Get a forward sentinel one past the end of the joined range. */
        [[nodiscard]] constexpr auto end()
            noexcept (requires{{make_join_iterator{*this}.end()} noexcept;})
            requires (requires{{make_join_iterator{*this}.end()};})
        {
            return make_join_iterator{*this}.end();
        }

        /* Get a forward sentinel one past the end of the joined range. */
        [[nodiscard]] constexpr auto end() const
            noexcept (requires{{make_join_iterator{*this}.end()} noexcept;})
            requires (requires{{make_join_iterator{*this}.end()};})
        {
            return make_join_iterator{*this}.end();
        }

        /* Get a reverse iterator over the joined range. */
        [[nodiscard]] constexpr auto rbegin()
            noexcept (requires{{make_join_reversed{*this}.begin()} noexcept;})
            requires (requires{{make_join_reversed{*this}.begin()};})
        {
            return make_join_reversed{*this}.begin();
        }

        /* Get a reverse iterator over the joined range. */
        [[nodiscard]] constexpr auto rbegin() const
            noexcept (requires{{make_join_reversed{*this}.begin()} noexcept;})
            requires (requires{{make_join_reversed{*this}.begin()};})
        {
            return make_join_reversed{*this}.begin();
        }

        /* Get a reverse sentinel one before the beginning of the joined range. */
        [[nodiscard]] constexpr auto rend()
            noexcept (requires{{make_join_reversed{*this}.end()} noexcept;})
            requires (requires{{make_join_reversed{*this}.end()};})
        {
            return make_join_reversed{*this}.end();
        }

        /* Get a reverse sentinel one before the beginning of the joined range. */
        [[nodiscard]] constexpr auto rend() const
            noexcept (requires{{make_join_reversed{*this}.end()} noexcept;})
            requires (requires{{make_join_reversed{*this}.end()};})
        {
            return make_join_reversed{*this}.end();
        }
    };

}

    
}


#endif  // BERTRAND_ITER_JOIN_H